# 我的常用开发技巧



## **一、编译篇**

### 1.1 **CMAKE 构建系统**

一个非常简单的入门

某工程目录如下

 ![cmake_demo.jpg](https://z4a.net/images/2023/05/24/cmake_demo.jpg)

说明：工程的源文件放到了src下，这些源文件会依赖cJSON, httpclient, mbedtls这几个文件夹的一些文件, 工程中用到的头文件放到了inc下.

根目录的CMakeLists.txt 简单实现功能的写法

```cmake
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

# 项目信息
# required, should be soon after cmake_minimum_required().
project(onenet4OTA) # 写入工程名

set (CMAKE_C_COMPILER "/usr/bin/gcc")
set (CMAKE_CXX_COMPILER "/usr/bin/g++")
set (CMAKE_C_FLAGS "-g -Wall")

# 如果需要进行调试需要设置这个命令
set(CMAKE_BUILD_TYPE Debug)

# 向工程添加多个特定的头文件搜索路径，路径之间用空格分隔
# 相当于指定g++编译器的-I参数
include_directories (${CMAKE_SOURCE_DIR})
include_directories (${CMAKE_SOURCE_DIR}/inc)
include_directories (${CMAKE_SOURCE_DIR}/httpclient/include)
include_directories (${CMAKE_SOURCE_DIR}/cJSON)

# 把src目录下的源文件存列表存放到变量SOURCES里
file(GLOB SOURCES src/*.c)

# 指定生成目标
add_executable(${PROJECT_NAME} ${SOURCES})

add_subdirectory(mbedtls)
add_subdirectory(httpclient)
add_subdirectory(cJSON)

target_link_libraries(${CMAKE_PROJECT_NAME} mbedlts httpclient cJSON)

# 设置生成目标后exe文件存放位置
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
```

子/组件目录的写法：

```cmake
file(GLOB SRC *.c) #包含该目录的所有.c的文件列表
include_directories(.) #当前路径为头文件搜索路径
# 生成该组件的静态库
add_library(cJSON STATIC 
    ${SRC}
    )
```

看看其他几个文件夹的CmakeLists.txt

```cmake
file(GLOB SRC src/*.c)
include_directories(include)
add_library(httpclient STATIC
    ${SRC}
    oneos/http_oneos_wrapper.c
    )
```

如何编译这个项目？

在根目录创建一个 build（可以根据个人喜好命名）文件夹，cd 进去 

```shell
mkdir build
cd build
cmake ../

cmake --build .
```

 ![cmake_build.gif](https://z4a.net/images/2023/05/24/cmake_build.gif)


> 备注：cmake自带的常用变量
>
> PROJECT_SOURCE_DIR：工程的根目录
>
> PROJECT_BINARY_DIR：运行cmake命令的目录，通常为${PROJECT_SOURCE_DIR}/build
>
> PROJECT_NAME：返回通过 project 命令定义的项目名称
>
> CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径
>
> CMAKE_CURRENT_BINARY_DIR: target 编译目录
>
> CMAKE_CURRENT_LIST_DIR: CMakeLists.txt 的完整路径
>
> EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置
>
> LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置


参考：

生成多个可执行文件将add_executable 修改如下

```cmake
file( GLOB_RECURSE mains RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}"
    "${CMAKE_CURRENT_SOURCE_DIR}/test_server.c"
    "${CMAKE_CURRENT_SOURCE_DIR}/test_client.c"
)

#遍历生成可执行文件
foreach(mainfile IN LISTS mains)
    get_filename_component(mainfile ${mainfile} NAME_WE)
    add_executable(${mainfile} ${mainfile})
endforeach()
```

### 1.2 Scons

#### 1.2.1 一些通用的技巧

Sconstruct 脚本里:

​	Decider函数可以设定编译根据什么理由进行更新 . 例如：Decider('content') 或者 Decider("timestamp-newer")

​	Library 函数可以来生成库， 例如： Library('foo', ['f1.c', 'f2.c', 'f3.c'])



在scons 中通过 scons --verbose 可以看到具体编译每一个文件执行了什么操作，例如最终生成oneos.elf 的指令如下：

> arm-none-eabi-gcc -o oneos.elf -mcpu=cortex-m3 -mthumb -ffunction-sections -fdata-sections -Wl,--gc-sections,-Map=oneos.map,-cref,-u,Reset_Handler -T board/linker_scripts/link.lds -L F:\code\gitlab\oneos/drivers/link/ build\bsp\application\main.o build\bsp\application\testlib\testlib.o build\bsp\board\board.o build\bsp\board\CubeMX_Config\Src\bsp.o build\bsp\board\CubeMX_Config\Src\stm32f1xx_it_bsp.o build\bsp\board\CubeMX_Config\Src\stm32f1xx_hal_msp.o build\bsp\board\CubeMX_Config\Src\system_stm32f1xx.o board\startup\startup_stm32f103xe_gcc.o build\arch\arm\armv7m\gcc\arch_exception_gcc.o build\arch\arm\armv7m\gcc\arch_task_switch_gcc.o build\arch\arm\armv7m\arch_task.o build\arch\arm\armv7m\arch_exception.o build\arch\arm\armv7m\arch_interrupt.o build\arch\arm\armv7m\arch_misc.o build\arch\arm\armv7m\arch_atomic.o build\kernel\source\os_block.o build\kernel\source\os_clock.o build\kernel\source\os_event.o build\kernel\source\os_idle.o build\kernel\source\os_kernel_lock.o build\kernel\source\os_kernel_log.o build\kernel\source\os_mb.o build\kernel\source\os_mem_firstfit.o build\kernel\source\os_mem_pool.o build\kernel\source\os_memory.o build\kernel\source\os_mq.o build\kernel\source\os_mutex.o build\kernel\source\os_sched.o build\kernel\source\os_sem.o build\kernel\source\os_spinlock.o build\kernel\source\os_startup.o build\kernel\source\os_task.o build\kernel\source\os_timer.o build\kernel\source\os_util.o build\kernel\source\os_version.o build\kernel\source\os_workqueue.o build\drivers\graphic\graphic.o build\drivers\graphic\atk_tflcd9341.o build\drivers\graphic\font\font_asc2_1608.o build\drivers\graphic\font\font_asc2_2412.o build\drivers\graphic\font\font_asc2_3216.o build\drivers\hal\st\devices\stm32_devices.o build\drivers\hal\st\drivers\drv_gpio.o build\drivers\hal\st\drivers\drv_usart.o build\drivers\hal\st\drivers\drv_hwtimer.o build\drivers\hal\st\drivers\drv_pwm.o build\drivers\hal\st\drivers\drv_pulse_encoder.o build\drivers\hal\st\drivers\drv_spi.o build\drivers\hal\st\drivers\drv_adc.o build\drivers\hal\st\drivers\drv_dac.o build\drivers\hal\st\drivers\drv_can.o build\drivers\hal\st\drivers\drv_rtc.o build\drivers\hal\st\drivers\flash\drv_flash_f1.o build\drivers\hal\st\drivers\drv_iwdg.o build\drivers\hal\st\drivers\drv_sram.o build\drivers\hal\st\drivers\drv_common.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_dma.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_cortex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_crc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_pwr.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_cec.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_exti.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_usart.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_spi.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_can.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_dac.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_dac_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_iwdg.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_fsmc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_sram.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash_ex.o build\drivers\infrared\infrared.o build\drivers\infrared\remote_control_atk.o build\drivers\sensors\sensor.o build\drivers\sensors\photo_diode.o build\components\dlog\source\dlog.o build\components\dlog\source\backend\console_backend.o build\components\dlog\source\syslog\syslog.o build\components\shell\source\shell_buildin_cmd.o build\components\shell\source\shell_main.o build\components\shell\source\shell_process.o build\components\shell\source\shell_symbol.o build\libc\source\common\gmtime_r.o build\libc\source\newlib\chdir.o build\libc\source\newlib\dirent.o build\libc\source\newlib\fcntl.o build\libc\source\newlib\fsync.o build\libc\source\newlib\getcwd.o build\libc\source\newlib\ioctl.o build\libc\source\newlib\libc.o build\libc\source\newlib\mkdir.o build\libc\source\newlib\rmdir.o build\libc\source\newlib\statfs.o build\libc\source\newlib\stdio.o build\libc\source\newlib\syscalls.o build\libc\source\newlib\time.o build\common\source\option_parse.o build\common\source\ring_blk_buff.o build\common\source\ring_buff.o build\drivers\misc\adc.o build\drivers\block\block_device.o build\drivers\bus\bus.o build\drivers\can\can.o build\drivers\timer\clockevent.o build\drivers\timer\clocksource.o build\drivers\timer\clocksource_cortexm.o build\drivers\console\console.o build\drivers\misc\dac.o build\drivers\device.o build\drivers\dma\dma_ram.o build\drivers\driver.o build\drivers\eeprom\eeprom.o build\drivers\eeprom\eeprom_info.o build\drivers\fal\fal.o build\drivers\fal\fal_block.o build\drivers\fal\fal_mtd.o build\drivers\fal\fal_part.o build\drivers\timer\hrtimer.o build\drivers\i2c\i2c.o build\drivers\mtd\mtd.o build\drivers\pin\pin.o build\drivers\misc\pulse_encoder.o build\drivers\misc\push_button.o build\drivers\misc\pwm.o build\drivers\rtc\rtc.o build\drivers\serial\serial.o build\drivers\sflash\sfbus.o build\drivers\sflash\sfdp.o build\drivers\sflash\sfdp_basic.o build\drivers\sflash\sflash.o build\drivers\sflash\sflash_info.o build\drivers\dma\soft_dma.o build\drivers\i2c\soft_i2c_bus.o build\drivers\i2c\soft_i2c_bus_config.o build\drivers\spi\spi_core.o build\drivers\spi\spi_dev.o build\drivers\timer\timer.o build\drivers\boot\cotex-m\vector_table.o build\drivers\watchdog\watchdog.o -lc -lm



我们烧录到stm32芯片内部的bin文件是通过对oneos.elf进行如下的转换生成的

arm-none-eabi-objcopy -R .reserved_ram -O binary oneos.elf oneos.bin

> 注： arm-none-eabi-objcopy -R参数： Remove section <name> from the output
>
> objcopy -O binary 时会删掉一些编译器产生的中间段.
>
> oneos 之所以删掉 reserved_ram 这个自定义的段，是因为这个段里存储的数据不用保存到ROM中。同时因为链接文件头RAM0定义的地址和ROM的地址不连续，如果不删除，在做objcopy时，会自动填充不连续部分，导致bin文件体积变得巨大。


> 在 osconfig.py 的 CFLAGS 或者 LFLAGS 加上 --verbose 也可以看到gcc的编译或者链接过程

scons的一些操作

> scons --debug=explain 为啥要编译这个文件
>
> scons --tree=all 打印编译文件的所有依赖信息
>
> scons --tree=all build\drivers\watchdog\watchdog.o 后面的文件为编译文件位于build目录的相对路径
>
> scons --debug=presub 打印具体执行了什么操作来编译的

 ![scons_debug.gif](https://z4a.net/images/2023/05/24/scons_debug.gif)



OneOS 的 oos 构建系统是基于scons的，所以有些oos没有的功能，可以去改cube的脚步来实现。

例如实现 scons --tree=all build\drivers\watchdog\watchdog.o

可以去修改cube 目录下的 core/scripts/subcmd/build.py

```

def __init__(self):
...
			self.parser.add_argument('-t', '--tree', dest='if_tree',
                                 action='store',
                                 help='print the build tree.')

def parse(self, argv):
...
            output = args.output
            if_tree = args.if_tree
...
				if if_tree:
                params_dict['oos_build'].append('-t')
                params_dict['oos_build'].append(if_tree)
                params_dict['scons'].append('--tree=all {}'.format(if_tree))    
```



#### 1.2.2 OneOS 中SConscript 的一些函数

- DeleteSrcFile 可以用来删除列表中不需要参加编译的文件，如 DeleteSrcFile(src, 'mbedtls-v2.16.8/library/net_sockets.c')
- PresentDir 是获得当前路径的函数
- AddCodeGroup 是添加一个编译文件group

遍历目录下的所有SConscript文件

```python
pwd = PresentDir()

for root, dir_list, file_list in os.walk(pwd):
    scons_files = [f for f in file_list if f.endswith("SConscript")]
    for f in scons_files:
        if os.path.relpath(os.path.join(root, f), pwd) != f:
            # print(os.path.relpath(os.path.join(root, f), pwd))
            group = group + SConscript(os.path.relpath(os.path.join(root, f), pwd))
```



scons 把文件打包成库再链接只需要在sconscript 的  AddCodeGroup 语句加上 LIBRARY=[] 就可以

```
AddCodeGroup('test_app', src = src, depend = [''], LIBRARY = [], LINKFLAGS=linkflags)
```

将库链接到到工程中，scons写法：

```
cwd = PresentDir()

LIBS    = ['audio_player.a', 'migu_music.a', 'mp3_decoder.a']
LIBPATH = [cwd]


group = AddCodeGroup('package_lib', [], depend = [''], LIBS = LIBS, LIBPATH = LIBPATH)
```



在oneos上，包含init_call 的函数文件在编译成库再链接后，因为 init_call 这个段没有实际被调用导致被优化，因此如果需要将库中的符号全部链接到目标文件，可以在编译参数中添加  -Wl,--whole-archive 和 -Wl,-no-whole-archive。如下是一个示例。

```python
import os
import osconfig
from build_tools import *

pwd = PresentDir()

src  = Glob('*.c')
path =  [pwd]
group = []

libname = 'test_app'

link_libname = pwd + '/lib' + libname + '.a'
linkflags = ' -Wl,--whole-archive ' + link_libname + ' -Wl,-no-whole-archive'

#将*.c的代码编译成库
# group += AddCodeGroup(libname, src = src, depend = [''], LIBRARY = []) 

#将链接参数添加到目标文件的链接参数中
group += AddCodeGroup(libname, src = '', depend = [''], LINKFLAGS=linkflags) 

Return('group')
```





1.1章中所提到的工程用scons的脚本如下：

根目录脚本：

```python
import os

cwd = os.getcwd()

env = Environment()

# 工程名
env["project_name"] = "sconsTest"

inc_path = [
    cwd,
    cwd + '/inc',
    cwd + '/httpclient/include',
    cwd + '/cJSON',
    cwd + '/mbedtls']
# inc_path = [cwd + '/inc']

#
env.Append(CCFLAGS = ['-g'])
env.Append(CPPPATH = [inc_path])

# 生成文件位置
env['build_bin_root'] = ['#/build/bin/']

#Export 和子目录的Import对应，是为了传递env变量
Export('env')

objs = []

VariantDir('build', 'src')

# #src目录的文件包含程序入口执行的main函数, 需要编成object, 并且放到obj最开始，就不用考虑库循环链接的问题
# objs += SConscript('src/SConscript', variant_dir="build/src", duplicate=0)

list = os.listdir(cwd)
for d in list:
    path = os.path.join(cwd, d)
    # if os.path.isfile(os.path.join(path, 'SConscript')) and not d == 'src': #不再编译src目录
    if os.path.isfile(os.path.join(path, 'SConscript')):
        objs = objs + SConscript(os.path.join(d, 'SConscript'), variant_dir="build/" + d, duplicate=0)

# 构建可执行文件
bin = env.Program(target = env["project_name"], source = objs )
env.Install(env["build_bin_root"], bin)
```



文件夹目录：

```python
import os

Import('env')
env = env.Clone()
#print(env.Dump())

pwd     = os.getcwd()
src     = Glob('*.c')

env.Append(CPPPATH = [pwd])

# group = Library('cjson', src)  #将文件编译成不依赖项目编译参数的库
# group = env.Library('cjson', src) #依赖项目编译参数的库
group = env.Object(src)

Return('group')
```

使用scons编译两个目标，并将编译中间文件和目标文件放到build目录下：

```
VariantDir('build', '.', duplicate=False) #stablish target files built in a separate directory tree from the source files

src = ['build/sndwav_common.c', 'build/wav_parser.c']

lplay_src = src + ['build/lplay.c']
lrecord_src = src + ['build/lrecord.c']

libs = ['asound']

Program( target= 'build/lplay', source = lplay_src, LIBS = libs)

Program( 'build/lrecord', source = lrecord_src, LIBS = libs)
```

```
scons: Reading SConscript files ...
scons: done reading SConscript files.
scons: Building targets ...
scons: building associated VariantDir targets: build
gcc -o build/sndwav_common.o -c sndwav_common.c
gcc -o build/wav_parser.o -c wav_parser.c
gcc -o build/lplay.o -c lplay.c
gcc -o build/lplay build/sndwav_common.o build/wav_parser.o build/lplay.o -lasound
gcc -o build/lrecord.o -c lrecord.c
gcc -o build/lrecord build/sndwav_common.o build/wav_parser.o build/lrecord.o -lasound
scons: done building targets.
```



从预编译的src中删除某个代码：

```python
if not IsDefined(['USING_AUDIO_MP3_TEST']):
    DeleteSrcFile(src, 'mp3_test.c')
```



### 1.3 GCC

gcc交叉编译工具链的命名规则：arch [-vendor] [-os] [-(gnu)eabi] [-gcc]

arch： 体系架构，如 ARM，MIPS

vendor： 工具链提供商，没有 vendor 时，用 none 代替；

os： 目标操作系统，没有 os 支持时，也用 none 代替

eabi： 嵌入式应用二进制接口（Embedded Application Binary Interface）

如果同时没有 vendor 和 os 支持，则只用一个 none 代替。例如 arm-none-eabi 中的 none 表示既没有 vendor 也没有 os 支持。 



根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如

- arm-none-eabi：这个是没有操作系统的，它使用的是newlib这个专用于嵌入式系统的C库。

- arm-none-linux-eabi：用于Linux的，使用Glibc



GCC 循环链接问题的解决：

```makefile
-Wl,--start-group

1*.a 2*.a 

-Wl,--end-group
```

链接参数：

> -L 指定查找链接库的位置
>
> -l 指定链接库名称 (-lc 标准c库 -lm math库)
>
> -T 指定链接脚本



### 1.4 Makefile

Makefile 文件无法在线调试，可以使用 --debug 参数让 make 打印详细的信息来协助理解，或者是在 Makefile 中添加一些打印信息，常用打印方式有两种：

方法1，在makefile中采用如下的语句： 

```makefile
$(info, xxxx$(xxx))
$(warning, xxxx$(xxx))
$(error, xxxx$(xxx))
```

其中，\$(xxx) 表示某个变量。这三个命令可以加到 Makefile 的任意地方，注意 \$(error, xxxx$(xxx)) 会终止 Make 过程。

方法2，在makefile中采用如下语句：

```makefile
@echo "xxxx $xx xxxx"
```

其中，\$(xxx) 表示某个变量。**这个命令只能用在目标后边，且前面是个TAB**。这个就是标准 Makefile 语法中的一个命令。

make 的工作的一些机制：

> a. 如果给出了参数，则 make 优先去找匹配的规则（匹配规则：完整匹配 > 通配符半匹配 > 完全通配符匹配）去执行；如果没有给出参数，make 会自动找到 Makefile 中第一个目标中没有通配符的规则执行。
>
> b. 如果中间遇到 include 其他文件，就会紧接着执行 include 的文件，完成后再继续执行本文件。
> c. make 总是从 Makefile 的开头开始解析，并不是找到匹配目标之后仅执行匹配目标的命令。也就是说，在匹配之前，Make 可能已经解析了很多判断条件。
> d. 对于匹配的规则如果有依赖，优先解析依赖。注意，依赖的匹配也符合 1 中所说的规则。
> e. 命令前面加了 @ 字符，则不显示命令本身而只显示它的结果。命令前面加了 - 号，即使这条命令出错，make 也会继续执行后续命令。
> f. 如果 Makefile 中存在多条同名规则，则 make 程序会尝试将他们合并。但是如果这些同名规则都有命令的话，make 会给出警告，并用后面的命令代替前面的命令。
> 原文链接：https://blog.csdn.net/ZCShouCSDN/article/details/122239526



### 1.5 其他

4.1 消除参数未使用参数告警的方法

```c
#define UNUSED(x) ((void)(x))
```

4.2  编译阶段打印宏的预编译值

```c
#define PRINT_MACRO_HELPER(x)   #x
#define PRINT_MACRO(x)          #x "=" PRINT_MACRO_HELPER(x)

#pragma message(PRINT_MACRO(NUMBER_MACRO))
```

举例：

```c
#include <stdio.h>

#define PRINT_MACRO_HELPER(x)   #x
#define PRINT_MACRO(x)          #x "=" PRINT_MACRO_HELPER(x)

#define NUMBER_MACRO            3.14159
#define STRING_MACRO            "This is a string."

#pragma message(PRINT_MACRO(NUMBER_MACRO))
#pragma message(PRINT_MACRO(STRING_MACRO))
#pragma message(PRINT_MACRO(UNDEF_MACRO))

#define UNUSED(x) ((void)(x))

int test(int para)
{
  UNUSED(para);

  printf("Hello,world!\r\n");
  return 0;
}
```

编译时会打印

> (base) root@PC-202010131037:build_test# gcc -Wunused-parameter -c test.c -o test.o
> 
> test.c:9:9: note: #pragma message: NUMBER_MACRO=3.14159
> 
>     9 | #pragma message(PRINT_MACRO(NUMBER_MACRO))
>    
>       |         ^~~~~~~
>    
> test.c:10:9: note: #pragma message: STRING_MACRO="This is a string."
> 
>    10 | #pragma message(PRINT_MACRO(STRING_MACRO))
>    
>       |         ^~~~~~~
>    
> test.c:11:9: note: #pragma message: UNDEF_MACRO=UNDEF_MACRO
> 
>    11 | #pragma message(PRINT_MACRO(UNDEF_MACRO))
>    
>       |         ^~~~~~~
>    



4.3 写跨平台的项目常常需要在代码中判断平台的类型，加载不同的资源以及使用不同的接口。在不同的平台中编译器中定义了不同的宏。常用的如下

```c
Windows平台
_WIN32 32位和64位系统都有定义
_WIN64 仅64位系统有定义

Unix平台
unix
__unix
__unix__

Mac OS X 平台
__APPLE__
__MACH__

Linux平台
__linux__
linux
__linux
```

4.4 windows 设置环境变量

```
setx HELIX_RUNTIME "%userprofile%\source\repos\helix\runtime"

`%userprofile%` resolves to your user directory like `C:\Users\Your-Name\` for example.
```



## **二、日志篇**

### 2.1 比较常用的C语言预定义宏

```c
__LINE__  ：当前程序行的行号，表示为十进制整型常量

__FILE__  ：当前源文件名，表示字符串型常量

__DATE__ ：转换的日历日期，表示为Mmm dd yyyy 形式的字符串常量

__TIME__  ：转换的时间，表示"hh:mm:ss"形式的字符串型常量，是由asctime产生的。

Gcc/ARMCC 还支持 __func__ 和 __FUNCTION__ (windows下vc6.0编译器不支持)

C++ 中的 __cplusplus
```



宏定义也支持变参

C99 标准新增加的一个 `__VA_ARGS__` 预定义标识符来表示前面的变参列表

```
#define LOG(fmt,...) printf(fmt, ##__VA_ARGS__)
```

注意：标识符 `__VA_ARGS__` 前面加上宏连接符 ##，这样做的好处是，当变参列表非空时，## 的作用是连接 fmt，和变参列表，各个参数之间用逗号隔开，宏可以正常使用；当变参列表为空时，## 还有一个特殊的用处，它会将固定参数 fmt 后面的逗号删除掉，这样宏也可以正常使用

还有一种写法

```c
#define LOG(fmt,args...) printf(fmt,##args)
```

使用预定义标识符 `__VA_ARGS__` 来定义一个变参宏，是 C99 标准规定的写法。而上面这种格式是 GNU C 扩展的一个新写法。我们不再使用 `__VA_ARGS__`，而是直接使用 args... 来表示一个变参列表，然后在后面的宏定义中，直接使用 args 代表变参列表就可以了。

例如，linux中：

```c
#if defined(CONFIG_DYNAMIC_DEBUG)
#define pr_debug(fmt, ...) \
    dynamic_pr_debug(fmt, ##__VA_ARGS__)
#elif defined(DEBUG)
#define pr_debug(fmt, ...) \
    printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
#else
#define pr_debug(fmt, ...) \
    no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
#endif

#define dynamic_pr_debug(fmt, ...)                \
do {                                \
    DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt); \
    if (unlikely(descriptor.flags       \
            & _DPRINTK_FLAGS_PRINT))    \
        __dynamic_pr_debug(&descriptor, pr_fmt(fmt),    \
                   ##__VA_ARGS__);      \
} while (0)

static inline __printf(1, 2)
int no_printk(const char *fmt, ...)
{
    return 0;
}

#define __printf(a, b)    \   
__attribute__((format(printf, a, b)))
```

这个宏定义了三个版本。如果我们在编译内核时有动态调试选项，那么这个宏就定义为 dynamic_pr_debug。如果没有配置动态调试选项，那我们还可以通过 DEBUG 这个宏，来控制这个宏的打开和关闭。

no_printk() 作为一个内联函数，定义在 printk.h 头文件中，而且通过 format 属性声明，指示编译器按照 printf 标准去做参数格式检查。

最有意思的是 dynamic_pr_debug 宏，宏定义采用 do{ ... }while(0) 结构。这看起来貌似有点多余，有它没它，我们的宏都可以工作。反正都是执行一次，为什么要用这种看似“画蛇添足”的循环结构呢？道理很简单，这样定义就是为了防止宏在条件、选择等分支结构的语句中展开后，产生宏歧义。 



小技巧： Vscode 上可以把我们经常定位代码流程打印的代码如

```c
os_kprintf("%s-%d enter\r\n", __func__, __LINE__);
```

定义为代码片段，并起一个简单的缩写，当键入这个缩写时，就会扩展成这句代码。

方法：

 [![p97g4VH.png](https://s1.ax1x.com/2023/05/24/p97g4VH.png)](https://imgse.com/i/p97g4VH)  [![p97gWrD.png](https://s1.ax1x.com/2023/05/24/p97gWrD.png)](https://imgse.com/i/p97gWrD)

然后编辑c.json文件

```json
{
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	"output include": {
		"prefix": "in",
		"body": [
			"#include \"\""
		],
		"description": "input include files"
	}

	"log to c file": {
		"prefix": "osk",
		"body": [
			"os_kprintf(\"== %s-%d : %d ==\\r\\n\", __func__, __LINE__, __LINE__);"
		],
		"description": "quick log"
	},

	"printf_log": {
		"prefix": "pr",
		"body": [
			"printf(\"== %s-%d ==\\r\\n\", __func__, __LINE__);"
		],
		"description": "quick printf log"
	}
}
```

  ![osk.gif](https://z4a.net/images/2023/05/24/osk.gif)

网上的一个这种代码片段格式生成小工具 https://snippet-generator.app/ 



### 2.2 undef

有的时候，想关掉某一个文件里的打印，又不想全局关log，就可以在文件开头重新把打印函数作为宏定义给重新定义成空，这样不会改动代码，效率也很高。

\#ifdef DEBUG

\#undef DEBUG

\#endif



### 2.3 函数返回值

函数调用，就一定会有参数和返回值的传递问题，因此也就产生了多种不同的编程范式，比如：

1. Posix 风格：函数返回值只用来表示成功(0)或失败(非0)，其他的输出结果都使用参数来传递。
2. Unix 风格：函数返回值即包括错误代码，也包括有用的输出结果。


## 三、工具篇

### 3.1 **linux子系统**

Windows 都自带了一个linux子系统，这样不用安装虚拟机，就可以很快的通过命令行在这个linux子系统上验证一些功能。

开启方法如下：

1.开启windows的开发者选项

 [![p97gfqe.png](https://s1.ax1x.com/2023/05/24/p97gfqe.png)](https://imgse.com/i/p97gfqe)

2.控制面板中选择“适用于Linux的Windows子系统”

 [![p97gTPI.png](https://s1.ax1x.com/2023/05/24/p97gTPI.png)](https://imgse.com/i/p97gTPI)

3.然后再windows的应用商店中搜索Ubuntu并进行安装

  [![p97g5ad.png](https://s1.ax1x.com/2023/05/24/p97g5ad.png)](https://imgse.com/i/p97g5ad)

4.安装时需要设置linux子系统的账号和密码
[![p97g7Gt.png](https://s1.ax1x.com/2023/05/24/p97g7Gt.png)](https://imgse.com/i/p97g7Gt)

安装完成后，再bash或者powershell中输入bash就可以开启这个安装的只有命令行的ubuntu子系统。

5. wsl 连接外部usb

   - powelshell中安装usbipd-win： 

```powershell
winget install --interactive --exact dorssel.usbipd-win
```

   - 安装用户空间工具和 USB 硬件标识符数据库。 这些说明适用于 Ubuntu

```shell
apt install linux-tools-generic hwdata
   
update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20
```

   - 附加 USB 设备

```shell
usbipd wsl list
usbipd wsl attach --busid 
lsusb
```

   - 解绑

```powershell
usbipd wsl detach --busid 
```



6. wsl 重启

   通过Windows cmd或powershell执行如下命令：

   wsl --shutdown

   

   查看本机的wsl 的实例：

   wsl -l -v

   

   设置 Ubuntu-20.04 为 WSL 2

   ```bash
    wsl.exe --set-version Ubuntu-20.04 2
   ```

​	

Windows 上操作 Linux

在 Windows 文件资源管理器左侧可以找到 Linux 的标志，点击 Linux 就可以操作 Linux 文件



将 WSL 2 设置为默认版本

```
wsl --set-default-version 2
```



\# 终止指定的Linux分发版（也可直接点击窗口右侧“X”关闭） 

```
wsl -t <Linux分发版名称>
```



7. 查看linux信息

cat /etc/issue （Linux查看版本当前操作系统发行版信息）

hostname # 查看计算机名

free -m # 查看内存使用量和交换区使用量

### 3.2 VSCODE

#### 3.2.1 常用的vscode快解键

工作区快捷键

| Mac 快捷键           | Win 快捷键               | 作用                                          | 备注                 |
| :------------------- | :----------------------- | :-------------------------------------------- | :------------------- |
| **Cmd + Shift + P**  | **Ctrl + Shift + p**，F1 | 显示命令面板                                  |                      |
| **Cmd + B**          | **Ctrl + b**             | 显示/隐藏侧边栏                               | 很实用               |
| `Cmd + \`            | `Ctrl + \`               | **拆分为多个编辑器**                          | Ctrl+alt+→/←         |
|                      | Ctrl+alt+\               | 视图：合并所有编辑器                          | 自定义快捷键         |
| **Cmd + 1、2**       | **Ctrl + 1、2**          | 聚焦到第 1、第 2 个编辑器                     | 同上重要             |
| **Cmd + +、Cmd + -** | **ctrl + +、ctrl + -**   | 将工作区放大/缩小（包括代码字体、左侧导航栏） | 在投影仪场景经常用到 |
| Cmd + J              | Ctrl + J                 | 显示/隐藏控制台                               |                      |
| **Cmd + Shift + N**  | **Ctrl + Shift + n**     | 重新开一个软件的窗口                          | 很常用               |
| Cmd + Shift + W      | Ctrl + Shift + w         | 关闭软件的当前窗口                            |                      |
| Cmd + n              | Ctrl + n                 | 新建文件                                      |                      |
| Cmd + w              | Ctrl + w                 | 关闭当前文件                                  |                      |

跳转操作

| Mac 快捷键                    | Win 快捷键             | 作用                                                   | 备注               |
| :---------------------------- | :--------------------- | :----------------------------------------------------- | :----------------- |
| Cmd + `                       | 没有                   | 在同一个软件的**多个工作区**之间切换                   | 使用很频繁         |
| **Cmd + Option + 左右方向键** | Ctrl + Pagedown/Pageup | 在已经打开的**多个文件**之间进行切换                   | 非常实用           |
| Ctrl + Tab                    | Ctrl + Tab             | 在已经打开的多个文件之间进行跳转                       | 不如上面的快捷键快 |
| Cmd + Shift + O               | Ctrl + shift + o       | 在当前文件的各种**方法之间**（符号：Symbol）进行跳转   |                    |
| Cmd + t                       | Ctrl + t               | 在当前**工作区**的各种方法之间（符号：Symbol）进行跳转 |                    |
| Ctrl + g                      | Ctrl + g               | 跳转到指定行                                           |                    |
| `Cmd+Shift+\`                 | `Ctrl+Shift+\`         | 跳转到匹配的括号                                       |                    |

移动光标

| Mac 快捷键                    | Win 快捷键                   | 作用                                                         | 备注           |
| :---------------------------- | :--------------------------- | :----------------------------------------------------------- | :------------- |
| 方向键                        | 方向键                       | 在**单个字符**之间移动光标                                   | 大家都知道     |
| **option + 左右方向键**       | **Ctrl + 左右方向键**        | 在**单词**之间移动光标                                       | 很常用         |
| **Cmd + 左右方向键**          | home/end                     | 将光标定位到当前行的最左侧、最右侧（在**整行**之间移动光标） | 很常用         |
| **Option + Alt + 左右方向键** | **Alt + Shift + 左右方向键** | 左右扩大/缩小选中的范围                                      | 很酷，极为高效 |
| Cmd + ↑                       | Ctrl + Home                  | 将光标定位到文件的第一行                                     |                |
| Cmd + ↓                       | Ctrl + End                   | 将光标定位到文件的最后一行                                   |                |
| Cmd + Shift + \               | ctrl+shift+\                 | 在**代码块**之间移动光标                                     |                |

编辑操作

| Mac 快捷键             | Win 快捷键          | 作用                                 | 备注                                   |
| :--------------------- | :------------------ | :----------------------------------- | :------------------------------------- |
| Cmd + C                | Ctrl + C            | 复制                                 |                                        |
| Cmd + X                | Ctrl + X            | 剪切                                 |                                        |
| Cmd + V                | Ctrl + V            | 粘贴                                 |                                        |
| **Cmd + Enter**        | **Ctrl + Enter**    | 在当前行的下方新增一行，然后跳至该行 | 即使光标不在行尾，也能快速向下插入一行 |
| Cmd+Shift+Enter        | Ctrl+Shift+Enter    | 在当前行的上方新增一行，然后跳至该行 | 即使光标不在行尾，也能快速向上插入一行 |
| **Option + ↑**         | **Alt + ↑**         | 将代码向上移动                       | 很常用                                 |
| **Option + ↓**         | **Alt + ↓**         | 将代码向下移动                       | 很常用                                 |
| Option + Shift + ↑     | Alt + Shift + ↑     | 将代码向上复制一行                   |                                        |
| **Option + Shift + ↓** | **Alt + Shift + ↓** | 将代码向下复制一行                   | 写重复代码的利器                       |

删除操作

| Mac 快捷键             | Win 快捷键           | 作用                   | 备注                                      |
| :--------------------- | :------------------- | :--------------------- | :---------------------------------------- |
| Cmd + shift + K        | Ctrl + Shift + K     | 删除整行               | 「Cmd + X」的作用是剪切，但也可以删除整行 |
| **option + Backspace** | **Ctrl + Backspace** | 删除光标之前的一个单词 | 英文有效，很常用                          |
| option + delete        | Ctrl + delete        | 删除光标之后的一个单词 |                                           |
| **Cmd + Backspace**    |                      | 删除光标之前的整行内容 | 很常用                                    |
| Cmd + delete           |                      | 删除光标之后的整行内容 |                                           |

备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。

多列选择/多列编辑

多列选择是更高效的多光标选择，所以单独列成一小段。

| Mac 快捷键                | Win 快捷键             | 作用                                                         | 备注                 |
| ------------------------- | ---------------------- | ------------------------------------------------------------ | -------------------- |
| Cmd + Option + 上下键     | Ctrl + Alt + 上下键    | 在连续的多列上，同时出现多个光标                             | 较常用               |
| Option + Shift + 鼠标拖动 | Alt + Shift + 鼠标拖动 | 按住快捷键，然后把鼠标从区域的左上角拖至右下角，即可在选中区域的每一行末尾，出现光标。从右下角到左上角，则是行首出现 | 很神奇的操作，较常用 |
| **Option + Shift + i**    | **Alt + Shift + i**    | 选中一堆文本后，按下快捷键，既可在**每一行的末尾**都出现一个光标。 |                      |

编程语言相关

| Mac 快捷键             | Win 快捷键      | 作用                         | 备注                 |
| :--------------------- | :-------------- | :--------------------------- | :------------------- |
| Cmd + /                | Ctrl + /        | 添加单行注释                 | 很常用               |
| **Option + Shift + F** | Alt + shift + f | 代码格式化                   | 很常用               |
| F2                     | F2              | 以重构的方式进行**重命名**   | 改代码备             |
| Cmd + U                | Ctrl + u        | 将光标的移动回退到上一个位置 | 撤销光标的移动和选择 |

搜索相关

| Mac 快捷键          | Win 快捷键          | 作用                                       | 备注   |
| :------------------ | :------------------ | :----------------------------------------- | :----- |
| **Cmd + Shift + F** | **Ctrl + Shift +F** | 全局搜索代码                               | 很常用 |
| **Cmd + P**         | **Ctrl + P**        | 在当前的项目工程里，**全局**搜索文件名     |        |
| Cmd + F             | Ctrl + F            | 在当前文件中搜索代码，光标在搜索框里       |        |
| **Cmd + G**         | **F3**              | 在当前文件中搜索代码，光标仍停留在编辑器里 | 很巧妙 |

命令面板的使用

Mac 用户按住快捷键 `Cmd+Shift+P` （Windows 用户按住快捷键`Ctrl+Shift+p`），可以打开快速命令面板。



自动格式化粘贴的内容

在设置项里搜索 `editor.formatOnPaste`，将设置项改为`true`



去掉每一行末尾的空格。在设置项里搜索`空格`或者`"files.trimTrailingWhitespace"`，将值设置为 true



搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：

![img](http://img.smyhvae.com/20190415_2052.png)



![20211012_1548](http://img.smyhvae.com/20211012_1548.png)



![img](https://img.smyhvae.com/20211012_1609.png)

鼠标操作

- 在当前行的位置，鼠标三击，可以选中当前行。
- 用鼠标单击文件的**行号**，可以选中当前行。
- 在某个**行号**的位置，**上下移动鼠标，可以选中多行**



| 快捷键                  | 操作                                                         | 备注         |
| ----------------------- | ------------------------------------------------------------ | ------------ |
| Ctrl+k，Ctrl+s          | 显示快捷键                                                   |              |
| Ctrl+l                  | 选择当前行                                                   | 小写的L      |
| Ctrl+shift+L            | 选择所有出现的当前选择                                       |              |
| Ctrl+k, ctrl+x          | 删除尾部空格                                                 |              |
| Shift+alt+f             | 格式化文档                                                   |              |
| **Ctrl+x**              | **删除光标所在的当前行**                                     | **不用选中** |
| **Ctrl+c**              | **复制光标所在的当前行**                                     | **不用选中** |
| **Shift+alt+↑/↓**       | **复制粘贴当前行**                                           |              |
| **Alt+↑/↓**             | **交换上下行**                                               |              |
| **Ctrl+shfit+\\**       | **跳到对应的括号处**                                         |              |
| **Ctrl+[ 或者 ]**       | **缩进**                                                     |              |
| **Ctrl+End**            | **跳到文件末尾**                                             |              |
| **Ctrl+shfit+[ 或者 ]** | **折叠或展开代码片段**                                       |              |
| **ctrl+k ctrl+0**       | **折叠文件内所有代码片段**                                   |              |
| **ctrl+/**              | **注释/取消注释本行代码**                                    |              |
| Shift+Alt+a             | C语言文件用 /*  */ 注释代码                                  | 代码块注释   |
| Ctrl+T                  | 展示光标所在位置函数的定义                                   |              |
| **Ctrl+shift+o**        | **跳转到本文件函数等符号定义的位置**                         |              |
| **Alt+→/←**             | **下一步或者上一步**                                         |              |
| **Alt+click**           | **插入光标**                                                 | 列模式       |
| **Ctrl+alt+↑/↓**        | **在上/下方插入光标**                                        |              |
| **Ctrl+alt+→/←**        | **开关新的代码编辑页面**                                     | 分屏         |
| **ctrl+Y**              | **Redo**                                                     |              |
| **alt+z**               | **切换超出编辑器的代码显示，即多行变一行显示，一行变多行显示** |              |



Ctrl+shift+L: 同时选中当前文件的所有选择

 ![ctrl_shfit_L.gif](https://z4a.net/images/2023/05/24/ctrl_shfit_L.gif)

Ctrl+k, ctrl+x : 删除尾部的空格

 ![Ctrl_K_ctrl_x.gif](https://z4a.net/images/2023/05/24/Ctrl_K_ctrl_x.gif)

alt+shift+f 格式化文档

 ![shfit_alt_f.gif](https://z4a.net/images/2023/05/24/shfit_alt_f.gif)

ctrl+k, ctrl+f 格式化选中的代码段

 ![ctrl_K_CTRL_F.gif](https://z4a.net/images/2023/05/24/ctrl_K_CTRL_F.gif)

 ctrl+x 不用选中该行就删除光标所在的行.(同理的有ctrl+c)

![ctrl_x.gif](https://z4a.net/images/2023/05/24/ctrl_x.gif)

alt+↑/↓ （键盘的上下方向键） 将光标所在的行上下移动

 ![alt_up.gif](https://z4a.net/images/2023/05/24/alt_up.gif)

ctrl+shift+\ 跳到对应的括号处

 ![ctrl_shift_slash.gif](https://z4a.net/images/2023/05/24/ctrl_shift_slash.gif)

ctrl+] 向右缩进，ctrl+[向左缩进

 ![ctrl_square_bracket.gif](https://z4a.net/images/2023/05/24/ctrl_square_bracket.gif)

ctrl+k, ctrl+0  折叠代码片段 ctrl+k, ctrl+j  展开代码片段
 ![ctrl_k_ctrl_0.md.gif](https://z4a.net/images/2023/05/24/ctrl_k_ctrl_0.gif)

ctrl+/ 注释行代码

shift+alt+a 添加/* */格式的注释

 [![shiftalta.gif](https://z4a.net/images/2023/05/24/shiftalta.gif)

ctrl+alt+↑/↓ 列模式

 [![ctrl_alt_direction.md.gif](https://z4a.net/images/2023/05/24/ctrl_alt_direction.gif)



vscode综合操作实例：

1. 有的时候在网上复制了一些代码到vscode中，变成了一行，如下:
```
#include <unistd.h>       ssize_t read(int fd, void *buf, size_t count);       ssize_t write(int fd, const void *buf, size_t count);       #include <sys/types.h>       #include <sys/socket.h>       ssize_t send(int sockfd, const void *buf, size_t len, int flags);       ssize_t recv(int sockfd, void *buf, size_t len, int flags);       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                      const struct sockaddr *dest_addr, socklen_t addrlen);       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                        struct sockaddr *src_addr, socklen_t *addrlen);       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);       ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
```

不好查看，可以先使用alt+z (快捷键配置关键字：自动换行)把超出编辑器的代码切换成全部显示到屏幕上。

然后需要把这些代码格式化，直接 shift+alt+f 或者选中后 ctrl+k,ctrl+f 都不好使。可以先把空格替换成'\n'（搜索时需要勾上正则表达式），然后就变成了成多行代码。

接着使用  shift+alt+f 或者选中后 ctrl+k,ctrl+f  格式化这些代码（格式化代码时会删除行尾的空格）。

最后把符合正则表达式 ^\s*(?=\r?$)\n 的格式替换成空（删除空行，vscode只勾选正则表达式）

 ![vscode_demo.gif](https://z4a.net/images/2023/05/24/vscode_demo.gif)



#### 3.2.2 格式化插件 clang-format

Ctrl+, 打开配置，搜索format。

1）可以勾选Format on save时会在保存文件时对文件进行格式化。

2）否则快捷键 alt+shift+f 时会格式化文件，ctrl+K，ctrl+F 可以格式化勾选的代码片段。

规则为vscode代码根目录下的.clang-format文件，如下为gitee上我司开源代码的format规则文件


```
---
Language:        Cpp
# BasedOnStyle:  LLVM
AccessModifierOffset: -2
AlignAfterOpenBracket: Align
AlignConsecutiveMacros: true
AlignConsecutiveAssignments: true
AlignConsecutiveDeclarations: true
AlignEscapedNewlines: Right
AlignOperands: true
AlignTrailingComments: true
AllowAllArgumentsOnNextLine: false
AllowAllConstructorInitializersOnNextLine: false
AllowAllParametersOfDeclarationOnNextLine: false
AllowShortBlocksOnASingleLine: false
AllowShortCaseLabelsOnASingleLine: false
AllowShortFunctionsOnASingleLine: None
AllowShortLambdasOnASingleLine: All
AllowShortIfStatementsOnASingleLine: Never
AllowShortLoopsOnASingleLine: false
AlwaysBreakAfterDefinitionReturnType: None
AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: false
AlwaysBreakTemplateDeclarations: MultiLine
BinPackArguments: false
BinPackParameters: false
BraceWrapping:
  AfterCaseLabel:  true
  AfterClass:      true
  AfterControlStatement: true
  AfterEnum:       true
  AfterFunction:   true
  AfterNamespace:  true
  AfterObjCDeclaration: false
  AfterStruct:     true
  AfterUnion:      true
  AfterExternBlock: false
  BeforeCatch:     true
  BeforeElse:      true
  IndentBraces:    false
  SplitEmptyFunction: true
  SplitEmptyRecord: true
  SplitEmptyNamespace: false
BreakBeforeBinaryOperators: None
BreakBeforeBraces: Custom
BreakBeforeInheritanceComma: false
BreakInheritanceList: BeforeColon
BreakBeforeTernaryOperators: true
BreakConstructorInitializersBeforeComma: false
BreakConstructorInitializers: BeforeColon
BreakAfterJavaFieldAnnotations: false
BreakStringLiterals: true
ColumnLimit:     120
CommentPragmas:  '^ IWYU pragma:'
CompactNamespaces: false
ConstructorInitializerAllOnOneLineOrOnePerLine: false
ConstructorInitializerIndentWidth: 4
ContinuationIndentWidth: 4
Cpp11BracedListStyle: true
DerivePointerAlignment: false
DisableFormat:   false
ExperimentalAutoDetectBinPacking: false
FixNamespaceComments: true
ForEachMacros:
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH
IncludeBlocks:    Preserve
IncludeCategories:
  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
    Priority:        3
  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
    Priority:        2
  - Regex:           '.*'
    Priority:        1
IncludeIsMainRegex: '(Test)?$'
IndentCaseLabels: false
IndentPPDirectives: None
IndentWidth:     4
IndentWrappedFunctionNames: false
JavaScriptQuotes: Leave
JavaScriptWrapImports: true
KeepEmptyLinesAtTheStartOfBlocks: true
MacroBlockBegin: ''
MacroBlockEnd:   ''
MaxEmptyLinesToKeep: 1
NamespaceIndentation: None
ObjCBinPackProtocolList: Auto
ObjCBlockIndentWidth: 2
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: true
PenaltyBreakAssignment: 2
PenaltyBreakBeforeFirstCallParameter: 19
PenaltyBreakComment: 300
PenaltyBreakFirstLessLess: 120
PenaltyBreakString: 1000
PenaltyBreakTemplateDeclaration: 10
PenaltyExcessCharacter: 1000000
PenaltyReturnTypeOnItsOwnLine: 60
PointerAlignment: Right
ReflowComments:  true
SortIncludes:    false
SortUsingDeclarations: true
SpaceAfterCStyleCast: false
SpaceAfterLogicalNot: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeCpp11BracedList: false
SpaceBeforeCtorInitializerColon: true
SpaceBeforeInheritanceColon: true
SpaceBeforeParens: ControlStatements
SpaceBeforeRangeBasedForLoopColon: true
SpaceInEmptyParentheses: false
SpacesBeforeTrailingComments: 4
SpacesInAngles:  false
SpacesInContainerLiterals: true
SpacesInCStyleCastParentheses: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
Standard:        Cpp11
StatementMacros:
  - Q_UNUSED
  - QT_REQUIRE_VERSION
TabWidth:        4
UseTab:          Never
...
```

有一些代码，我们并不想让clang-format调整格式，这时可以使用注释临时禁用clang-format

```
// clang-format off

这两个注释中间的代码不受clang-format的影响

// clang-format on
```



使用默认的clang format 文件配置：

![vscode_clangformat_setting](https://www.z4a.net/images/2024/04/02/vscode_clangformat_setting1.jpg)



#### 3.2.3 配置终端为oneos-cube

配置终端设置 -->  Automation Profile:Window (在setting json中编辑)

```
"terminal.integrated.profiles.windows": {
...
"OneOS-Cube": {
  "path": [
    "D:\\software\\OneOSCube\\components\\cmder\\OneOS-Cube.exe"
  ],
  "args": [],
}
}


```



#### 3.3.4 插件

Gitlens  -- 一个git扩展

Hex Editor  -- hex文件查看

highlight-words -- 高亮代码

Indent-Rainbow -- 以不同颜色展示缩进的扩展

Better Comments 

Code Spell Checker

compareit --文件对比插件

Markdown Preview Github Styling

vscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。

indent-rainbow  突出显示代码缩进

TODO Highlight 安装了插件之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。

CodeSnap 代码截图

WakaTime 统计在 VS Code 里写代码的时间

CodeGeeX  AI 生成代码

#### 3.3.5 文件排除

如果有的文件找不到，有可能是被vscode按照gitignore的规则排除了，可以勾选这个选项避免被gitignore的文件不被搜索到

[![vscode_search_ignore.png](https://z4a.net/images/2023/07/21/vscode_search_ignore.png)](https://z4a.net/image/VBDS2C)



在开发文件夹下创建 .vscode 的settings.json.

ctrl+shift+p 打开设置窗口搜索 settings.json 出现打开工作区设置时，点击就会在工作区.vscode目录下添加settings.json



```json
{
    "files.associations": {
        "SConscript": "python",
        "SConstruct": "python",
        "Kconfig": "kconfig",
        "*.S": "asmble",
        "*.map": "arm",
        "*.dtsi": "c"
    },

    "files.exclude": {
        "**/.git": true,
        "**/.svn": true,
        "**/.hg": true,
        "**/CVS": true,
        "**/.DS_Store": true,
        "**/Thumbs.db": true,
        "u-boot/arch/[!a]*": true,
        "u-boot/arch/arc": true,
        "u-boot/arch/arm/mach-[!r]*": true,
        "u-boot/arch/arm/mach-rm*": true,
        "u-boot/arch/arm/thumb1": true,
        "u-boot/arch/arm/mach-rockchip/rk[!3]*": true,
        "u-boot/arch/arm/dts/[!r.]*": true
    },

    "search.exclude": {
        "system/": true,
        "!/system/**/*.ps*": true
      }
}
```



#### 3.3.6 使用vscode查看linux虚拟机的代码

利用ssh远程到linux虚拟机，因此虚拟机需要开启sshd服务（apt install openssh-server）

通过 vscode左下角的 >< 按键进入设置； 或者 ctrl+shfit+p 打开设置，输入 ssh ，在 ”Remote-SSH：“ 中先add一个host，再connect一个host就可以了。



可能会造成占用C盘过多的问题

 windows下删除该目录即可

C:\Users\\\<YourName>\AppData\Roaming\Code\User\workspaceStorage\

C:\Users\\\<YourName>\AppData\Local\Microsoft\vscode-cpptools\





#### 3.3.7 一些正则表达式

正则删除空行   

```
^[\t]*\n
```

正则删除相同行

```
^(.+)((?:\r?\n.*)*)(?:\r?\n\1)$

$1$2
```





#### 3.3.8 其他

a. vscode设置删除行尾空格

![trim_trailing_Whitespace.png](https://z4a.net/images/2024/01/03/trim_trailing_Whitespace.png)



参考：[VS Code的使用](https://web.qianguyihao.com/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-VS%20Code%E7%9A%84%E4%BD%BF%E7%94%A8.html)

b. 搜索

搜索栏包含或者排除的文件语法：

```
components/**/*.yaml ---- 两个*号匹配多层目录
components/*/*.yaml  ---- 1个*号匹配1层目录
components/**/*.yaml,*.txt ---- 包含多个项目时，可以用逗号分隔开

搜素同时存在 free 和 malloc的文件，打开正则表达式选项
(free[\n\s\S]*malloc)|(malloc[\n\s\S]*free)
```

c.  .vscode 文件夹的妙用

.vscode目录下一般有 4 种配置文件和项目中的代码片段
extensions.json：推荐当前项目使用的插件
setting.json：vscode编辑器和插件的相关配置
launch.json：调试配置文件
task.json：任务配置
xxxxxxx.code-snippets：项目中共享的代码片段
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/qq_44741577/article/details/137885682



### 3.3 窗口置顶或者截图置顶

推荐一个全局手势工具 [WGestures](http://www.yingdev.com/projects/wgestures) （可以置顶窗口）或者 [snipaste](https://zh.snipaste.com/) （很好用的截图工具，按下 `F1` 来开始截图，再按 `F3`，截图就在桌面置顶显示了）

 ![wgestures_ontop.jpg](https://z4a.net/images/2023/05/24/wgestures_ontop.jpg)

 [![p97ggxK.jpg](https://s1.ax1x.com/2023/05/24/p97ggxK.jpg)](https://imgse.com/i/p97ggxK)

被WGestures 吐槽了

![assist_peng.png](https://z4a.net/images/2023/11/29/assist_peng.png)

### 3.4 Git

#### 3.4.1 cherry-pick

git cherry-pick用于把另一个本地分支的commit修改应用到当前分支。

简单用法：


- git cherry-pick <commit id>



#### 3.4.2 git remote


- git remote add myown git@xxx.git //添加远程仓库为myown
- git branch --set-upstream-to=origin/remote_branch your_branch
- git branch -u origin/remote_branch

其中，origin/remote_branch是你本地分支对应的远程分支；your_branch是你当前的本地分支。

#### 3.4.3 gitignore

.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的

解决办法

A.

```
git rm -r --cached .
git add .
git commit -m 'update .gitignore'
```

 

B.

```
git rm --cached file/path/to/be/ignored。
git add .
git commit -m "fixed untracked files"
```

 

#### 3.4.4 git clone/clean/push/config

git clone 指定分支, “-b”选项指定要克隆的分支名称，"--single-branch”选项告诉Git只克隆指定的分支，而不是整个代码库。

```
git clone -b dev_jk --single-branch git@xxx.git
```

删除当前目录下所有没有track过的文件和文件夹. 不管他是否是.gitignore文件里面指定的文件夹和文件

```
git clean -xfd
```

远程已有remote_branch分支但未关联本地分支local_branch且本地已经切换到local_branch

```
git push -u origin/remote_branch
```

远程没有remote_branch分支并，本地已经切换到local_branch

```
 git push origin local_branch:remote_branch
```

文件没有改动但status显示又很多文件被改动了，是因为文件模式被改动了。取消检查文件模式改动

```
git config --global --add core.filemode false
```

如果不起作用

使用git config --list 查看一下，是否修改掉，如果有多条，把他们都替换掉

```
git config --replace-all core.filemode false
```



#### 3.4.5 修改提交记录

1）修改上一次提交修改记录的时间戳

```
 git commit --amend --date="2023-11-03T15:46:30" 
```

2) 修改上一次提交记录的作者信息，--no-edit 表示不弹出编辑框，直接修改记录

```
git commit --amend --author="yz <yz@126.com>" --no-edit
```

3）合并历史提交记录

git rebase -i --root 可以切换到第一条提交记录

然后在现实的vi串口中编辑(快捷键： ctrl +a 可以切换)

a. 需要修改的记录将 pick 修改成edit

b. 需要合并的记录将 pick 修改成 sqlash

wq 保存后，陆续键入

git rebase --continue进行修改直到结束



3.4.6 强制推送

git push -f [远程仓库名] [本地分支名]:[远程分支名]



3.4.7 git patch相关

```
git format-patch -1 将最近的第一个commit生成patch
```



将 old 到 new 的所有提交打成一个patch

```
git diff old_commit_hash_id new_old_commit_hash_id > xxx.patch
```



检查能否正确打入patch

```undefined
git apply --check xxx.patch 没有输出错误表明可以正确合入
```

打patch

```
git apply xxx.patch 单纯的将修改合入代码中
```

或者 

```
git am xxx.patch 会将commit也一并打入到仓库里
```



### 3.5 局域网文件传输

本地http 服务器

执行如下命令，可以在本地(127.0.0.1)启动一个端口号为8000的http服务
```
python -m http.server 
```

可以使用http://127.0.0.1:8000 访问这个http服务，页面为启动这个服务下文件列表

可以通过这个方法局域网传输一些文件




### 3.6 GDB调试

编译时添加编译选项 -g 后，程序就携带了调试符号信息。

启动gdb调试有三种方法：

1） gdb filename

2） gdb attach pid

某些场景下，程序启动了，但我们想调试该程序，又不想重启这个程序，就可以先获得这个程序的pid，使用 gdb attach pid 来调试

例如:

```shell
gcc -g ctime_test.c
```

```shell
./a.out &
```

```shell
(base) root@PC-202010131037:time_test# ps
  PID TTY          TIME CMD
   15 pts/0    00:00:00 bash
  220 pts/0    00:00:01 a.out
  221 pts/0    00:00:00 ps
```

```
gdb attach 220
```

3)  方法三 进程 Crash 之后如何定位问题——调试 core 文件

```
gdb filename corename
```

```
gdb a.out core
```



常用命令补充

tbreak 临时断点，一旦该断点触发后会自动删除

watch 监视变量或者内存，每当该处的值有变化时，就会中断程序

display 该命令监视的变量或者内存的值，每次程序中断都会打印

条件断点  

```
break [lineNo] if [condition]
```

添加条件断点，还有一个方法就是先添加一个普通断点，然后使用 **condition 断点编号 断点触发条件** 这样的格式来添加。

4) gdb tui 模式(穿上内裤的gdb)

a. ctrl+x, a 打开/关闭source串口

b. layout src / asm 打开源码/汇编窗口

c. layout split

d. ctrl+n / ctrl+p 切换焦点

[![p97cbB4.jpg](https://s1.ax1x.com/2023/05/24/p97cbB4.jpg)](https://imgse.com/i/p97cbB4)



带参数的调试

```
gdb --args ./test 123
```



objdump 参数

-C -x -S



### 3.7 Spacevim

安装：

```shell
curl -sLf https://spacevim.org/cn/install.sh | bash
```

使用 Vim 搭建 C/C++ 开发环境

SpaceVim 初次安装时默认并未启用相关语言模块。首先需要启用 `lang#c` 模块，通过快捷键 `SPC f v d` 打开配置文件，添加如下片断：

```
[[layers]]
  name = "lang#c"
  enable_clang_syntax_highlight = true  #基于clang解析的语法高亮

[[layers]]
  name = "lsp" #代码自动补全
  iletypes = [
    "c",
    "cpp"
  ]
  [layers.override_cmd]
    c = ["clangd"]

[[layers]]
  name = "format" #代码格式化,主要依赖 format 模块,快捷键为 SPC b f,异步执行 clang-format 命令
```

工程文件自动跳转

SpaceVim 自带工程管理插件，可以识别项目根目录，自动跳转 alternate 文件。需要在项目根目录添加工程文件 `.project_alt.json`：

```
{
  "*.c": {"alternate": "{}.h"},
  "*.h": {"alternate": "{}.c"}
}
```

通过以上的配置，就可以使用命令 `:A` 在源文件和测试文件之间进行跳转。

通过快捷键 `Leader + 序号` 来跳转到对应的标签页或者是文件。默认的 Leader 是 `\` 键。

一些快捷键

普通模式下  u 撤销(undo), ctrl + r 反撤销(redo)

| `SPC f v d` | 打开 SpaceVim 的用户配置文件 |
| ----------- | ---------------------------- |
|             |                              |

   

vim 和系统剪切板互相复制粘贴

```
apt install vim-gtk

"+y 复制
"+p 粘贴
"+yy  // 复制当前行到剪切板
"+p   // 将剪切板内容粘贴到光标后面
"ayy  // 复制当前行到寄存器 a
"ap   // 将寄存器 a 中的内容粘贴到光标后面
```



Helix 

一款基于rust的编辑器。

通过 hx --tutor 或者 :tutor 获取使用教程



使用：

- d 删除光标后的字符

- :w f:\test\1.txt 保存文件到f:\test\1.txt

- i 光标之前插入

- I( shift+i ) 行首插入

- A(shift+a) 行尾插入

- O（shift+o）在上一行插入 

- w 选择下一个单词 （shift + w 选择一个整个单词）

- b 选择到前一个单词的开头

- c 修改当前的选择

- 2w 先后移动2个单词

- x 选择一行

- shift+u redo

- shift+c  列选择，逗号退出列选择

- \> 缩进

- \< 减小缩进

- ctrl+a 增加数字

- ctrl+x 减小数字






### 3.8 python

#### 3.8.1 miniconda

Conda 是一个是为 Python 而设的开源包管理系统和环境管理系统，用于安装 Python 及相应的包（库），其实就是 Python 环境安装、运行、管理平台，也就是说，Conda 已经附带有了 Python，安装了它就不需要另外安装 Python 了。

之所以选择安装 Conda 来代替单独安装 Python，是因为：单独安装 Python 后，当需要安装其他包（库），特别是第三方包（库）的时候，Python 的包管理工具 pip 在下载安装包过程中往往会出现这样或那样的问题，比如会忽略某个包的其他依赖包，这样会造成该包在安装后不能使用的情况，这就是大家经常吐槽的所谓的各种“坑”；而利用 Conda 来安装这些软件包就可以避免出现这些错误。

Conda 分为 Anaconda 和 Miniconda 两个版本，两个都是开源（免费）的。其中 Anaconda 可以说是 Conda 的大型版本，安装了很多的软件包；而 Miniconda 是 Conda 的最小安装程序（即Conda 的迷你版），可以说是 Anaconda 的一个简化版本，只包含 conda、Python 及其依赖的包，以及其他少量常用的包。

1. 安装 miniconda

```
linux 

wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
```



2. 配置源

   修改用户目录下的 `.condarc` 文件来使用 TUNA 镜像源

```
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/

conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/linux-64/
conda config --set show_channel_urls yes
```

3. 创建环境

```
conda create --name py39 python=3.9
```

4. 激活环境             

```
# 安装好后，使用activate激活某个环境
activate py35 #for Windows  

# for Linux & Mac
source activate py35
或者 conda activate py35
```

5. 删除环境

```
conda remove --name py35 --all          
```

​    

6. 查看系统中的所有环境

```
conda info -e
```

7. 包管理

```
conda list

conda install
```

8. 退出虚拟环境

```
linux: 
conda deactivate 

windows: 
deactivate your_env_name    
```

9. python 自带的虚拟环境

   ```bash
   python -m venv my_env  //在项目目录下运行该命令，创建一个my_env的虚拟环境
   ```

   

#### 3.8.2 格式化输出

​	使用+号拼接字符串

```python
name = 'jack'
slogan = 'bingo'
age = 24

print( jack + ' says: ' + slogan + ', age: ' + age)
```

占位符 

```python
print(" %s says %s, age: %d" %(jack, slogan, age))
```

其中%s、%d便是占位符，作用就是替后面的变量站住这个位置，字符串后面的%是一个特殊的操作符，该操作符会将后面的变量值，替换掉前面字符串中的占位符。

对比两种写法，会发现使用占位符可以:

将字符串中用到变量集中在一起，方便查找和修改

避免了反复使用引号，导致的引号对应识别困难

能够更直接通顺的看出句子的内容



目前常用的占位符写法有三种

1.% 占位符

语法格式如下：

```python
"... %[key][flags][width][.precision][length type]conversion type ..." % values
```

依次介绍下上面占位符每个符号每个字段的意思

- %: 必须要有的符号。它标记占位符的开始。
- key: 选填。映射的键，由带括号的字符序列组成，一般用于后面的values是是字典的场景。
- flags: 选填。转换标志(Conversion flags), 会影响某些转换类型的结果。
- width: 选填。最小字段宽度。如果指定为“*”（星号），则实际宽度从值中元组的下一个元素读取，要转换的对象位于最小字段宽度和可选精度之后。*
- *precision: 选填。精度，写法为.precision（点+精度）。如果指定为“*”（星号），则实际宽度从值中元组的下一个元素读取，要转换的值位于精度之后。
-  length type: 选填。长度修改器。
- Conversion type: 必须要有的符号。转换类型，也标记占位符的开始。   

Conversion type 类型有

- **`%s`**：用于字符串
- **`%d`**：用于整数
- **`%f`**：用于浮点数
- **`%x`**：用于十六进制整数
- **`%o`**：用于八进制整数
- **`%c`**：用于单个字符
- **`%e`**：用于科学计数法表示的浮点数

2.format语句

```python
print('{} {}'.format('hello','world')) 

print('{0} {1} {0}'.format('hello','world'))

print('{a} {a} {b}'.format(a = 'hello', b = 'world'))

print('{:b}'.format(20))

print('0x{:x}'.format(20))

print('{:e}'.format(20))

print('{:%}'.format(0.10))
```

> 结果：
>
> hello world
> 
> hello world hello
> 
> hello hello world
> 
> 10100
> 
> 0x14
> 
> 2.000000e+01
> 
> 10.000000%}
> 

   

3.f表达式

f-string用大括号 `{}` 表示被替换字段，其中直接填入替换内容

```python
name = 'Eric'
print(f'Hello, my name is {name}')

age = 18
print(f"""
My name is {name},
age {age}
""")

import datetime
e = datetime.datetime.today()
print(f'the time is {e:%Y-%m-%d (%a) %H:%M:%S}')   # datetime时间格式
```

> 输出结果：
>
> Hello, my name is Eric
>
> My name is Eric,
> age 18
>
> the time is 2023-05-23 (Tue) 21:40:34

#### 3.8.3 将模块当作脚本来执行

模块中的代码将被执行，就像导入它一样，但 `__name__` 将被设置为 `__main__`。

例如，有一个模块 `calc.py`，里面定义了一个 `add()` 函数。如果要测试这个函数，可以这样编写：

```python
def add(a, b):
    return a + b

if __name__ == '__main__':
    import sys
    args = sys.argv  # 用于获取命令行参数
    print(args)
    print(add(int(args[1]), int(args[2]))) #sys.argv[0]表示代码本身文件路径，参数索引从1开始
```

然后，就可以将其作为一个脚本来执行：

```
python calc.py
```

3.8.4 获取当前目录

```
import os

os.getcwd()
```



### 3.9 wps 宏

批量修改图片大小

```
Sub 批量设置图片格式()
'
' 批量设置图片格式 宏
'
'

'定义变量
Dim picwidth
Dim picheight

On Error Resume Next '忽略错误

'按照固定大小缩放，保持比例
picheight = 10  '单位厘米，可修改
picwidth = 2.5  '单位厘米，可修改


''类型1：嵌入式图形 InlineShapes类型图片
For Each Shape In ActiveDocument.InlineShapes

'按照固定大小缩放, 两行删一行即可
Shape.Height = picheight * 28.35 '设置图片高度为 10cm （1cm等于28.35px）
Shape.Width = picwidth * 28.35 '设置图片宽度8cm

Next


''类型2：非嵌入式图形，Shapes类型图片
For Each Shape In ActiveDocument.Shapes

'按照固定大小缩放, 两行删一行即可
Shape.Height = picheight * 28.35 '设置图片高度为 10cm （1cm等于28.35px）
Shape.Width = picwidth * 28.35 '设置图片宽度8cm

Next

End Sub
```

### 3.10 ssh 免密

生成rsa key

```
ssh-keygen -t rsa -b 4096 -C "demo"
```

将公钥xxx.pub 追加到服务器 ~/.ssh/authorized_keys 中

在windows 的 .ssh 目录下创建config 文件

```
Host demo
    HostName x.x.x.x
    Port 22
    User demo
    IdentityFile C:\Users\xxx\.ssh\id_rsa
```

powershell中使用 ssh demo 即可连接远程服务器



### 3.11 远程编译关闭powershell 后不中断编译

**tmux**：

1. 启动 `tmux` 会话：

   bash复制

   ```bash
   tmux
   ```

2. 在会话中运行编译命令。

3. 使用 `Ctrl+b`，然后按 `d` 键分离会话。

4. 关闭 SSH 连接后，会话和进程会继续运行，后续可以通过 `tmux attach` 重新连接

3.12 docker

命令添加**网易云** Docker 源

```
curl -fsSL https://mirrors.163.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://mirrors.163.com/docker-ce/linux/ubuntu bionic stable"
```

配置 Docker 阿里云镜像加速器

```
{
    "registry-mirrors": [
        “https://docker.xuanyuan.me”
    ]
}
```

重启docker服务

```
sudo systemctl daemon-reload
sudo systemctl restart docker
```

**验证配置是否生效**

```bash
sudo docker info | grep -A 3 "Registry Mirrors"
```

**拉取一个镜像测试**

```
sudo docker pull ubuntu:20.04
```

查看本地镜像

```
sudo docker images
```

创建并运行一个基于 Ubuntu 20.04 的容器

```
sudo docker run -it ubuntu:20.04 /bin/bash
```



## 四、通用的C语言代码库篇

### 4.1 安全的C函数

缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区，又被称为“堆栈”，在各个操作进程之间，指令会被临时储存在“堆栈”当中，“堆栈”也会出现缓冲区溢出。缓冲区溢出攻击是利用缓冲区溢出漏洞所进行的攻击行动。利用缓冲区溢出攻击，可以导致程序运行失败、系统关机、重新启动等后果。

缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务分段错误（Segmentation fault），另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。

C语言没有提供字符串类型，字符串以字符数组的形式出现，C标准库提供了一些操作字符串的函数，主要有：

strcmp 字符串比较函数，

strcpy 字符串拷贝函数，

strcat字符串连接函数，

sprintf格式化字符串拷贝函数等等。

因为字符串就是以‘\0’结束的一段内存，这些函数实质上也就是操作内存的函数。



不安全函数的替代

#### 4.1.1 函数gets  -->  fgets

```
头文件：
#include <stdio.h>

函数原型：
char *gets(char *buff);

函数说明：
从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。但换行符会被丢弃，然后在末尾添加'\0'字符，并由此来结束字符串。
```

【缓冲区溢出错误】读入stdin流中的字符串超过buff长度造成溢出。

错误代码：

```c
void main()
{
    char buf[1024];
    gets(buf);
}
//当输入内容超过1024大小
```



#### 4.1.2 strcpy --> strncpy/strlcpy

```c
头文件：
#include <string.h>

函数原型：
char *strcpy(char *dest, const char *src);

函数说明：
把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。】
```

不可以重叠是因为有可能造成拷贝的时候死循环，这从strcpy函数的实现原理可以看出。

实现原理：

```c
#include <stdio.h>
#include <assert.h> 
#include <string.h> 

char* strcpy(char *strDest, const char *strSrc) //const
{
    assert((strDest!=NULL) && (strSrc !=NULL));
    char *address = strDest;             
    while( (*strDest++ = *strSrc++) != '\0' )     
       ;

    return address ;
}
```

【缓冲区溢出错误】源字符串strSrc的字符数目大于目的字符串strDest的buff长度。

```
头文件：
#include <string.h>

函数原型：
char *strncpy(char *dest, const char *src, size_t n);

函数说明：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。最多复制n个字符。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。】
```

实现原理

```c
// vc6.0 source
char * __cdecl strncpy (
        char * dest,
        const char * source,
        size_t count
        )
{
    char *start = dest;
    while (count && (*dest++ = *source++))   /* copy string */
    	count--;

    if (count)                /* pad out with zeroes */
    	while (--count)
    		*dest++ = '\0';

    return(start);
}
```

一个最常见的问题，就是strncpy 并不帮你保证‘/0’结束。所以strncpy更像是特殊的memcpy。

正确使用方法【建议】：

```c
strncpy(dst, src, dst_size-1);
dst[dst_size-1] = '\0'; /* Always do this to be safe! */
```

strlcpy在复制之后dst字符串一定会以'\0'字符结尾 

```
strlcpy(dst, src, dst_size); /* dst[dst_size-1] will set '\0'*/
```



#### 4.1.3  strdup --> strndupa

 如果是为了复制一个字符串，那么更好的做法是使用 strdup 函数

```c
char* strdup(const char *s);
```

strdup 函数会调用 malloc 分配足够长度的内存并返回。

【特别注意】在你不使用的时候 free 它。

 

如果只是函数内部调用这个字符串，可以使用 strdupa 函数。

```c
char* strndupa(const char *s, size_t n);
```

 最多复制n个字符到栈内存分配的空间，并再在结尾增加一个'\0'。不用释放。

说明：strndupa 函数调用 alloca函数而非 malloc 函数分配内存，alloca 分配的内存是 桟内存而非堆内存。所以当函数返回后，内存就自动释放了，不需要 free。



#### 4.1.4  strcat --> strncat

```c
头文件：
#include <string.h>

函数原型：
char *strcat(char *dest, const char *src);

函数说明：
把src所指字符串添加到dest结尾处(覆盖dest结尾处的'\0')并添加'\0'。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串】
```

 

```c
头文件：
#include <string.h>

函数原型：
char *strncat(char *dest, const char *src, size_t n);

函数说明：
把src所指字符串的前n个字符或'\0'之前的字符添加到dest结尾处(覆盖dest结尾处的'\0')并添加'\0'。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串】
```

 

使用建议

```c
strncat(dest, source, dest_size-strlen(dest)-1);
```

#### 4.1.5  sprintf --> snprintf

```c
头文件：
#include <stdio.h>

函数原型：
int sprintf(char *buffer, const char *format, ...);

参数列表:
buffer：char型指针，指向将要写入的字符串的缓冲区
format：格式化字符串
[argument]...：可选参数，可以是任何类型的数据

返回值：字符串长度（strlen）
功能:把格式化的数据写入某个字符串缓冲区
```

 

```c
头文件：
#include <stdio.h>

函数原型：
int snprintf(char *buffer, size_t size, const char *format, ...);

参数列表:
buffer：char型指针，指向将要写入的字符串的缓冲区
size：最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个'\0'
format：格式化字符串
[argument]...：可选参数，可以是任何类型的数据

返回值：若成功则返回“欲”写入的字符串长度，若出错则返回负值
```

 特别注意返回值，与sprintf不同，如果输出因为size的限制而被截断，返回值将是“如果有足够空间存储，所应能输出的字符数(不包括字符串结尾的'/0')”，这个值和size相等或者比size大！也就是说，如果可以写入的字符串是 "0123456789ABCDEF" 共16位，但是size限制了是10，这样 snprintf() 的返回值将会是16 而不是 10 ！并且，如果返回值等于或者大于size，则表明输出字符串被截断了(truncated)。

 

错误示例：

```c
char buff[10]={0}; 
char str[] = "123456789012345678";
snprintf(buff, sizeof(buff), str); //如果后面的字符串str中有%s等转义字符，则会继续往后读取。
```

 

正确示例：

```c
char buff[10]={0}; 
char str[] = "123456789012345678";
snprintf(buff, sizeof(buff), "%s", str); //严格规范，结果是"123456789"
```

 

### 4.2 cJSON

在使用文件系统读取、存储一些文件时，建议可以使用json的文件格式，这样解析文件内容非常清晰易懂，cJSON这个组件使用起来也非常简单。 

Json格式化在线工具https://c.runoob.com/front-end/53/

#### 4.2.1  JSON语法规则

JSON对象是一个无序的"名称/值"键值对的集合：

- 以"{“开始，以”}"结束，允许嵌套使用
- 每个名称和值成对出现，名称和值之间使用":"分隔
- 键值对之间用","分隔
- 在这些字符前后允许存在无意义的空白符

对于键值，可以有如下值：

- 一个新的json对象
- 数组：使用"[“和”]"表示
- 数字：直接表示，可以是整数，也可以是浮点数
- 字符串：使用引号"表示
- 字面值：false、null、true中的一个(必须是小写)

示例如下：

```json
{
  "wifi_info": [
    {
      "ssid": "test",
      "passwd": "cmiot123"
    }
  ]
}
```

#### 4.2.2  cJSON 

git clone https://github.com/DaveGamble/cJSON.git

cJSON的源码文件只有两个：cJSON.h   cJSON.c

#### 4.2.3  cJSON数据封装

封装JSON数据的过程，其实就是创建链表和向链表中添加节点的过程。

① 创建头指针：

```c
cJSON* cjson_test = NULL;
```

② 创建头结点，并将头指针指向头结点：

```c
cjson_test = cJSON_CreateObject();
```

③ 向链表中添加节点：

```c
cJSON_AddNullToObject(cJSON * const object, const char * const name);

cJSON_AddTrueToObject(cJSON * const object, const char * const name);

cJSON_AddFalseToObject(cJSON * const object, const char * const name);

cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);

cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);

cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);

cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);

cJSON_AddObjectToObject(cJSON * const object, const char * const name);

cJSON_AddArrayToObject(cJSON * const object, const char * const name);
```

#### 4.2.4  输出JSON数据

上面讲述，一段完整的JSON数据就是一条长长的链表，那么，如何打印出这段JSON数据呢？

cJSON提供了一个API，可以将整条链表中存放的JSON信息输出到一个字符串中：

```c
(char *) cJSON_Print(const cJSON *item);
```

使用的时候，只需要接收该函数返回的指针地址即可。

#### 4.2.5  cJSON数据解析

解析方法: 解析JSON数据的过程，其实就是剥离一个一个链表节点(键值对)的过程。

解析方法如下：

① 创建链表头指针：

```c
cJSON* cjson_test = NULL;
```

② 解析整段JSON数据，并将链表头结点地址返回，赋值给头指针。

解析整段数据使用的API只有一个：

```c
(cJSON *) cJSON_Parse(const char *value);
```

③ 根据键值对的名称从链表中取出对应的值，返回该键值对(链表节点)的地址

```c
(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
```

④ 如果JSON数据的值是数组，使用下面的两个API提取数据：

```c
(int) cJSON_GetArraySize(const cJSON *array);

(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
```

#### 4.2.6 cJSON使用过程中的内存问题

cJSON提供了如下两个接口函数来删除对象。

```c
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);

CJSON_PUBLIC(void) cJSON_free(void *object);
```

cJSON_Delete();是用来释放json对象的，CJSON_free();是用来释放其他对象的.

当使用 cJSON_Create* 这类的函数创建的对象（如cJSON *cJSON_CreateObject(void);），需要使用cJSON_Delete来进行删除。该函数删除一条JSON数据时，如果有嵌套，会连带删除。

当调用这两个函数将对象转化为字符串时，需要使用CJSON_free来释放内存

```c
CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
```

例如：

```c
cJSON* wifi_config_json = NULL;
cJSON* info_array , *info_item, *new_item;
char*  info_str = NULL;
char*  read_buf = NULL;

wifi_config_json = cJSON_Parse(read_buf);
if( wifi_config_json ) {
info_array = cJSON_GetObjectItem(wifi_config_json, "wifi_info");
if( info_array ) {
    wifi_info_item_size = cJSON_GetArraySize(info_array);

    for( cnt = 0; cnt < wifi_info_item_size; cnt++ ) {
        info_item  = cJSON_GetArrayItem(info_array, cnt);
        temp_ssid  = cJSON_GetObjectItem(info_item, "ssid")->valuestring;
        temp_passwd = cJSON_GetObjectItem(info_item, "passwd")->valuestring;
        // ithPrintf("temp_ssid: %s, temp_ssid: %s\r\n", temp_ssid, temp_passwd);
        if( strncmp(temp_ssid, new_wifi_info->ssid, strlen(new_wifi_info->ssid)) == 0 ) {
            cJSON_DeleteItemFromArray(info_array, cnt);
            new_wifi_info->info_cnt--;
            ithPrintf("temp_ssid: %s, temp_ssid: %s, cnt: %d\r\n", temp_ssid, temp_passwd, cnt);
            break;
        }
    }

    if( (cnt == wifi_info_item_size) && (cnt > MAX_SAVE_WIFI_CONFIG_NUM) ) {
        cJSON_DeleteItemFromArray(info_array, 0);
        new_wifi_info->info_cnt--;
        ithPrintf("wifi config file cnt = %d > max(%d), delete the first one\r\n",
            cnt, MAX_SAVE_WIFI_CONFIG_NUM);
    }
    
    new_item = cJSON_CreateObject();
    cJSON_AddStringToObject(new_item, "ssid", new_wifi_info->ssid);
    cJSON_AddStringToObject(new_item, "passwd", new_wifi_info->passwd);
    cJSON_AddItemToArray(info_array, new_item);
    new_wifi_info->info_cnt++;
    ret = 0;
}
    
info_str = cJSON_PrintUnformatted(wifi_config_json);
cJSON_Delete(wifi_config_json);

if( info_str != NULL ) {
	cJSON_free(info_str);
}
```

### 4.3 Time

#### 4.3.1 时间概念

- UTC （**Coordinated Universal Time**，协调世界时），又称世界标准时间，也即格林威治标准时间(Greenwich Mean Time,GMT)。中国内地的时间与UTC得时差为+8，也即UTC+8，美国为UTC-5。
- 日历时间，是用"从一个标准时间点到此时的时间经过的秒数"来表示的时间。标准时间点对不同编译器可能会不同，但对一个编译系统来说，标准时间是不变的。一般是表示距离UTC时间 1970-01-01 00:00:00的秒数。

time.h 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数

**四个变量类型**

- size_t           无符号整数类型
- clock_t         存储处理器时间的类型，unsigned long
- time_t          存储日历时间的类型，和处理器相关的变量
- struct tm

定义的结构体如下：

```c
struct tm
{
  int tm_sec;     /* 秒，范围从 0 到 59    */
  int tm_min;     /* 分，范围从 0 到 59    */
  int tm_hour;    /* 小时，范围从 0 到 23   */
  int tm_mday;    /* 一月中的第几天，范围从 1 到 31   */
  int tm_mon;     /* 月，范围从 0 到 11(注意)       */
  int tm_year;    /* 自 1900 年起的年数            */
  int tm_wday;    /* 一周中的第几天，范围从 0 到 6    */
  int tm_yday;    /* 一年中的第几天，范围从 0 到 365  */
  int tm_isdst;   /* 夏令时                        */
};
```

**两个宏**

NULL	                      这个宏是一个空指针常量的值。

CLOCKS_PER_SEC	这个宏表示每秒的处理器时钟个数。
用于将clock()函数的结果转化为以秒为单位的量，这个量的具体值是与操作系统相关的，通常为1000。

#### 4.3.2 库函数



**clock函数**
函数原型： clock_t clock(void)

函数返回：返回clock函数执行起（一般为程序的开头），处理器时钟所使用的时间

函数功能：用来计算程序或程序的某一段的执行时间

实例

```c
#include<stdio.h>
#include<time.h>

int main()
{
    clock_t start_t,finish_t;
    double total_t = 0;
    int i = 0;
    start_t = clock();
    for(;i<100000;++i)
    {
        //do someting;
    }
    finish_t = clock();
    total_t = (double)(finish_t - start_t) / CLOCKS_PER_SEC;//将时间转换为秒

    printf("CPU 占用的总时间：%f\n", total_t);
    return 0;

}
```



**time函数**
函数原型: time_t time(time_t *timer)

参数说明: 

timer=NULL时得到当前日历时间（从1970-01-01 00:00:00到现在的秒数）

timer=时间数值时，用于设置日历时间，time_t是一个unsigned long类型。如果 timer不为空，则返回值也存储在变量 timer中。

函数功能: 得到当前日历时间或者设置日历时间

函数返回: 当前日历时间

实例

```c
#include <stdio.h>
#include <time.h>

int main ()
{
  time_t seconds;

  seconds = time(NULL);
  printf("自 1970-01-01 起的小时数 = %ld\n", seconds/3600);

  return(0);
}
```



**asctime函数**
函数原型: char* asctime(struct tm * ptr)

函数功能:将结构struct tm * ptr所表示的时间以字符串表示

函数返回: 返回的时间字符串格式为：星期,月,日,小时:分:秒,年

参数说明: 结构指针ptr应通过函数localtime()或gmtime()得到

实例

```c
#include <stdio.h>
#include <time.h>

int main() 
{
  struct tm now;

  now.tm_sec = 10;
  now.tm_min = 9;
  now.tm_hour = 8;
  now.tm_mday = 7;
  now.tm_mon = 6;
  now.tm_year = 120;
  now.tm_wday = 4;

  printf("%s\n", asctime(&now)); // Thu Jul  7 08:09:10 2020
}
```



**localtime函数**
函数原型: struct tm *localtime(const time_t *timer)

函数功能: 使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。

函数返回: 以tm结构表达的时间

实例

```c
#include <stdio.h>
#include <time.h>

int main ()
{
   time_t timer;
   struct tm *Now;

   time( &timer );
   Now = localtime( &timer );
   printf("当前的本地时间和日期：%s", asctime(Now));

   return(0);
}
```



**ctime函数**
函数原型: char *ctime(const time_t * timer)

函数功能: 将日历时间参数timer转换为一个表示本地当前时间的字符串

函数返回: 返回字符串格式：星期,月,日,小时:分:秒,年

参数说明: timer参数应由函数time获得，其等价于 astime( localtime(timer) )

实例

```c
#include <stdio.h>
#include <time.h>

int main ()
{
    time_t curtime;

    time(&curtime);
    printf("当前时间 = %s", ctime(&curtime));

    return(0);
}
```

**difftime函数**
函数原型: double difftime(time_t time2, time_t time1)

函数功能: 得到两次机器时间差，单位为秒

函数返回: 时间差，单位为秒

参数说明: time1,time2分别表示两个不同的机器时间，该参数应使用time函数获得

实例

```c
#include <time.h>  
#include <stdio.h>  
int main()  
{  
    time_t first,second;

    time(&first);
    sleep(5); 
    time(&second);
    printf("the diff time is: %f seconds", difftime(second,first));  //the diff time is 5.000000 seconds

    return 0;  
}  
```



**gmtime函数**
函数原型: struct tm *gmtime(time_t *timer)

函数功能: 得到以结构tm表示的时间信息，并用格林威治标准时间表示

函数返回: 以结构tm表示的时间信息指针

参数说明: timer用函数time()得到的时间信息

实例

```c
#include <stdio.h>
#include <time.h>

#define BST (+1)
#define CCT (+8)

int main ()
{

   time_t rawtime;
   struct tm *info;

   time(&rawtime);
   /* 获取 GMT 时间 */
   info = gmtime(&rawtime );

   printf("当前的世界时钟：\n");
   printf("伦敦：%2d:%02d\n", (info->tm_hour+BST)%24, info->tm_min);
   printf("中国：%2d:%02d\n", (info->tm_hour+CCT)%24, info->tm_min);

   return(0);
}
```



**mktime函数**
函数原型：time_t mktime(struct tm *timeptr)

函数功能：将时间转换为自1970年1月1日以来逝去时间的秒数

函数返回：该函数返回一个 time_t 值，该值对应于以参数传递的日历时间。如果发生错误，则返回 -1 值。

实例

```c
#include <stdio.h>
#include <time.h>

int main() {
  int ret;
  struct tm info;
  char buffer[80];

  info.tm_year = 2023 - 1900;
  info.tm_mon = 3 - 1;
  info.tm_mday = 17;
  info.tm_hour = 16;
  info.tm_min = 22;
  info.tm_sec = 10;
  info.tm_isdst = -1;

  ret = mktime(&info);
  if (ret == -1) {
    printf("Error\n");
  } else {
    strftime(buffer, sizeof(buffer), "%c", &info);
    printf("%s, ret: %u\n", buffer, ret); //Fri Mar 17 16:22:10 2023, ret: 1679041330
  }

  return 0;
}
```

**strftime函数**
函数原型: size_t strftime( char *strDest, size_t maxsize, const char *format, const struct tm *timeptr);

函数功能: 根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向 strDest中存放maxsize个字符。

参数说明: 转化结果存在s中，最多maxsize个字符写到s中

函数返回: 该函数返回向strDest指向的字符串中放置的字符数（不包括'\0'），如果字符数多于maxsize，函数返回0。

实例

```c
/*format如下：它们是区分大小写的。
    %a 星期几的简写
    %A 星期几的全称
    %b 月分的简写
    %B 月份的全称
    %c 标准的日期的时间串
    %C 年份的后两位数字
    %d 十进制表示的每月的第几天
    %D 月/天/年
    %e 在两字符域中，十进制表示的每月的第几天
    %F 年-月-日
    %g 年份的后两位数字，使用基于周的年
    %G 年分，使用基于周的年
    %h 简写的月份名
    %H 24小时制的小时
    %I 12小时制的小时
    %j 十进制表示的每年的第几天
    %m 十进制表示的月份
    %M 十时制表示的分钟数
    %n 新行符
    %p 本地的AM或PM的等价显示
    %r 12小时的时间
    %R 显示小时和分钟：hh:mm
    %S 十进制的秒数
    %t 水平制表符
    %T 显示时分秒：hh:mm:ss
    %u 每周的第几天，星期一为第一天 （值从0到6，星期一为0）
    %U 第年的第几周，把星期日做为第一天（值从0到53）
    %V 每年的第几周，使用基于周的年
    %w 十进制表示的星期几（值从0到6，星期天为0）
    %W 每年的第几周，把星期一做为第一天（值从0到53）
    %x 标准的日期串
    %X 标准的时间串
    %y 不带世纪的十进制年份（值从0到99）
    %Y 带世纪部分的十进制年份
    %z，%Z 时区名称，如果不能得到时区名称则返回空字符。
    %% 百分号
*/  

include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;
  struct tm *info;
  char buffer[80];

  time(&rawtime);
  info = localtime(&rawtime);

  strftime(buffer, sizeof(buffer), "%Y-%m-%e %H:%M:%S", info);  // 2023-03-17 16:55:50
  printf("%s\n", buffer);

  return 0;
}
```

### 4.4 C语言嵌入汇编

#### 4.4.1 简单的内嵌汇编

```assembly
__asm__ __volatile__("hlt");
```

 "\_\_asm\_\_"表示后面的代码为内嵌汇编，"\_\_volatile\_\_"表示编译器不要优化代码，后面的指令 保留原样。括号里面是汇编指令。



#### 4.4.2 内嵌汇编举例

使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：  

```assembly
__asm__ __violate__ ("movl %1,%0" : "=r" (result) : "m" (input));
```

- "movl %1,%0"是指令模板；"%0"和"%1"代表指令的操作数，称为占位符，内嵌汇编靠它们将C 语言表达式与指令操作数相对应。
- 指令模板后面用小括号括起来的是语言表达式，本例中只有两个："result"和"input"，他们按照出现的顺序分 别与指令操作数"%0"，"%1"对应；注意对应顺序：第一个表达式对应"%0"；第二个表达式对应"%1"，依次类推，操作数至多有10 个，分别用"%0","%1"...."%9"表示。
- 在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。 "result"前面的限制字符串是"=r"，其中"="表示"result"是输出操作数，"r" 表示需要将"result"与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是"result"本身，当然指令执行 完后需要将寄存器中的值存入变量"result"，从表面上看好像是指令直接对"result"进行操作，实际上GCC做了隐式处理，这样我们可以少写一 些指令。
- "input"前面的"r"表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。

#### 4.4.3 内嵌汇编语法

```
__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
```

共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用":"格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用":"格开，相应部分内容为空。例如：

```asm
__asm__ __volatile__("cli": : :"memory")
```



### 4.5 c语言小知识

#### 4.5.1 C99中的柔性数组

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 一个结构体，成员变量是未指明大小的数组
typedef struct _ArraryMemberStruct_Good_ {
    int num;
    char data[];
} ArraryMemberStruct_Good;

void main()
{
    // 打印结构体的大小
    int size = sizeof(ArraryMemberStruct_Good);
    printf("size = %d \n", size);

    // 为结构体指针分配空间
    ArraryMemberStruct_Good *ams = (ArraryMemberStruct_Good *)malloc(size + 1024);

    strcpy(ams->data, "hello");
    printf("ams->data = %s \n", ams->data);

    // 打印结构体指针、成员变量的地址
    printf("ams = 0x%p \n", ams);
    printf("ams->num  = 0x%p \n", &ams->num);
    printf("ams->data = 0x%p \n", ams->data);

    // 释放空间
    free(ams);
}
```

打印结果：

> size = 4
> ams->data = hello
> ams = 0x0x5628271876b0
> ams->num  = 0x0x5628271876b0
> ams->data = 0x0x5628271876b4

特点：

1. 结构体的大小变成了 4；
2. 为结构体指针分配空间时，除了结构体本身的大小外，还申请了 data 需要的空间大小；
3. 不需要为 data 单独分配空间了；
4. 释放空间时，直接释放结构体指针即可；



#### 4.5.2 C语言中一个\#个 2个\#\#的作用

1）一个\#的作用 

**#的功能是将其后面的宏参数进行字符串化操作（Stringfication），简单说就是在对它所引用的宏变量通过替换后在其左右各加上一个双引号。**比如下面代码中的宏：

```
#define WARN_IF(EXP) \
    do{ if (EXP) \
    fprintf(stderr, "Warning: " #EXP "\n");\
}while(0)
```

那么实际使用中会出现下面所示的替换过程：

```
WARN_IF (divider == 0);
```

被替换为

```
do {
    if (divider == 0)
    fprintf(stderr, "Warning" "divider == 0" "\n");
} while(0);
```

这样每次divider（除数）为0的时候便会在标准错误流上输出一个提示信息。

2）两个\#\#的作用

 **\##被称为连接符（concatenator），用来将两个Token连接为一个Token**。注意这里连接的对象是Token就行，而不一定是宏的变量。比如你要做一个菜单项命令名和函数指针组成的结构体的数组，并且希望在函数名和菜单项命令名之间有直观的、名字上的关系。那么下面的代码就非常实用：

```
struct command
{
    char * name;
    void (*function) (void);
};

\#define COMMAND(NAME) { NAME, NAME ## _command }
```

然后你就用一些预先定义好的命令来方便的初始化一个command结构的数组了：

```
struct command commands[] = {
    COMMAND(quit),
    COMMAND(help),
    ...
}
```

COMMAND宏在这里充当一个代码生成器的作用，这样可以在一定程度上减少代码密度，间接地也可以减少不留心所造成的错误。我们还可以n个##符号连接 n+1个Token，这个特性也是#符号所不具备的。

COMMAND宏在这里充当一个代码生成器的作用，这样可以在一定程度上减少代码密度，间接地也可以减少不留心所造成的错误。我们还可以n个##符号连接 n+1个Token，这个特性也是#符号所不具备的。



注意：

当宏参数是另一个宏的时候，需要注意的是宏定义里有用’#’或’##’的地方宏参数是不会再展开.


比如：

```
#define PR_LOG(x) putc(#x)
```

当 `PR_LOG(__LINE__)` 只会打印 `__LINE__`

可以用

```
#define _PR_LOG(x) putc(#x)

#define PR_LOG(x)  _log(x)
```

这样就可以打印出行号了



#### 4.5.3 c语言库函数需要引入的头文件

linux下通过man 指令可以查到，例如：

```
man memset
```

```
MEMSET(3)                                                        Linux Programmer's Manual                                                        MEMSET(3)

NAME
       memset - fill memory with a constant byte

SYNOPSIS
       #include <string.h>

       void *memset(void *s, int c, size_t n);
```

4.5.4  一些函数的小作用

| 函数名          | 作用                                                         | 头文件               |
| --------------- | ------------------------------------------------------------ | -------------------- |
| basename()      | 返回路径最后一个路径分隔符之后的内容,即获取文件名            | libgen.h             |
| dirname()       | 返回文件所在路径                                             | libgen.h             |
| getopt()        | 通过设置的**optstring**短参数指定‘:’ or ‘::’ or 不写‘:’获取带有‘-’后面的额外参数，具体可看例子理解这个函数，额外参数由全域变量 **optarg** 接收 | unistd.h             |
| __builtin_ffs() | __builtin_ffs 是 gcc 内置的函数，返回括号中数的二进制表示数的最后一个1在第几位(从后往前算)，如0x11，返回的是1；0x00返回的是0；0x02，返回的是2 | oneos 里的 os_ffs(), |
|                 |                                                              |                      |



```
#include <unistd.h>
#include <stdio.h>

int main(int argc, char *argv[])
{
	// 接收返回值
	int ret;
	// while 循环是在调用脚本的时候循环获取参数，直到获取到-1时退出，也就是脚本后面可跟多个参数。否则只能跟一个就退出了
	while((ret = getopt(argc,argv,"a:bc::")) != -1)
	{
	    switch(ret)
    	{
    		case 'a':
    		    printf("The argument of -a is: %s \n", optarg);
    		    break;
    		case 'b':
    		    printf("此参数没有额外参数\n");
    		    break;
    		case 'c':
    		    printf("The argument of -c is: %s \n", optarg);
    		    break;
    		default:
    		    return 0;
    	}
	}
	return 0;
}
//版权声明：本文为CSDN博主「人生长恨水」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
//原文链接：https://blog.csdn.net/qq_36956154/article/details/102507629
```

> ./a.out    //没有报错
>
> ./a.out -a  //带 -a 参数使用 但是后面不加额外参数
> 报错信息：./a.out: option requires an argument -- 'a' //报错信息可以看出我们在使用-a 参数时，需要在后面再加一个额外参数,那就加上一个参数试试看是否能正常输出内容
>
> ./a.out -a 0x05
> The argument of -a is: 0x05
>
> $ ./a.out -b
> 此参数没有额外参数



4.5.4 对齐

全局变量对齐：

```
__attribute__((aligned(4)))

// 例如:
struct stu{
　　 int length;
　　 char name[10];
}__attribute__ ((aligned (1))); 

static char tx_buffer[16] __attribute__((aligned(4)));
```



### 4.6 lwip(A Lightweight TCP/IP stack)

> lwIP is a small independent implementation of the TCP/IP protocol suite that has been initially developed by Adam Dunkels and is now continued here.
>
> The focus of the lwIP TCP/IP implementation is to reduce resource usage while still having a full scale TCP. This makes lwIP suitable for use in embedded systems with tens of kilobytes of free RAM and room for around 40 kilobytes of code ROM.



![tcpip.png](https://z4a.net/images/2024/02/20/tcpip.png)

TCP/IP协议栈各层的报文封装与拆封



> LwIP内核是由一系列模块组合而成的，这些模块包括：TCP/IP协议栈的各种协议、内存管理模块、数据包管理模块、网卡管理模块、网卡接口模块、基础功能类模块、API模块。每个模块是由相关的几个源文件和头文件组成的，通过头文件对外声明一些函数、宏、数据类型，使得其它模块可以方便地调用此模块的功能。而构成每个模块的头文件都被组织在了include目录中，而源文件则根据类型被分散地组织在api、apps、core、netif目录中。
>
> 
>
> 不同的系统有自己的一套Socket接口。Windows系统中支持的是WinSock，UNIX/Linux系统中支持的是BSD Socket，它们虽然风格不一致，但大同小异。LwIP中的Socket API是BSD Socket。但是LwIP并没有也没办法实现全部的BSD Socket，如果开发人员想要移植UNIX/Linux系统中的网络应用程序到使用LwIP的系统中，就要注意这一点。



以太网是指遵守 IEEE 802.3 标准组成的局域网，由 IEEE 802.3 标准规定的主要是位于参考模型的物理层(PHY)和数据链路层中的介质访问控制子层(MAC)。在家庭、企业和学校所组建的 PC 局域网形式一般也是以太网，其标志是使用水晶头网线来连接(当然还有其它形式)。 IEEE 还有其它局域网标准，如 IEEE 802.11 是无线局域网，俗称 Wi-Fi。 IEEE802.15 是个人域网，即蓝牙技术，其中的 802.15.4 标准则是 ZigBee 技术。

编码

为了让接收方在没有外部时钟参考的情况也能确定每一位的起始、结束和中间位置，在传输信号时不直接采用二进制编码。在 10BASE-T 的传输方式中采用曼彻斯特编码，在100BASE-T 中则采用 4B/5B 编码。

曼彻斯特编码把每一个二进制位的周期分为两个间隔，在表示“1”时，以前半个周期为高电平，后半个周期为低电平。表示“0”时则相反,如下图

![03295cf41cb9e9a2833e50ca36b6015a.png](https://z4a.net/images/2024/02/20/03295cf41cb9e9a2833e50ca36b6015a.png)



mac数据包格式

[![mac.png](https://z4a.net/images/2024/02/20/mac.png)](https://z4a.net/image/jPMECa)

MAC 数据包由前导字段、帧起始定界符、目标地址、源地址、数据包类型、数据域、填充域、校验和域组成。

- 前导字段，也称报头，这是一段方波，用于使收发节点的时钟同步。内容为连续 7 个字节的 0x55。字段和帧起始定界符在 MAC 收到数据包后会自动过滤掉。
- 帧起始定界符(SFD)： 用于区分前导段与数据段的，内容为 0xD5。
- MAC 地址： MAC 地址由 48 位数字组成，它是网卡的物理地址，在以太网传输的最底层，就是根据 MAC 地址来收发数据的。部分 MAC 地址用于广播和多播，在同一个网络里不能有两个相同的 MAC 地址。 PC 的网卡在出厂时已经设置好了 MAC 地址，但也可以通过一些软件来进行修改，在嵌入式的以太网控制器中可由程序进行配置。数据包中的 DA 是目标地址， SA 是源地址。
- 数据包类型： 本区域可以用来描述本 MAC 数据包是属于 TCP/IP 协议层的 IP 包、 ARP包还是 SNMP 包，也可以用来描述本 MAC 数据包数据段的长度。 如果该值被设置大于 0x0600，不用于长度描述，而是用于类型描述功能，表示与以太网帧相关的 MAC客户端协议的种类。
- 数据段： 数据段是 MAC 包的核心内容，它包含的数据来自 MAC 的上层。其长度可以从 0~1500 字节间变化。
- 填充域：由于协议要求整个 MAC 数据包的长度至少为 64 字节(接收到的数据包如果少于 64 字节会被认为发生冲突，数据包被自动丢弃)，当数据段的字节少于 46 字节时，在填充域会自动填上无效数据，以使数据包符合长度要求。
- 校验和域： MAC 数据包的尾部是校验和域，它保存了 CRC 校验序列，用于检错。

以上是标准的 MAC 数据包， IEEE 802.3 同时还规定了扩展的 MAC 数据包，它是在标准的 MAC 数据包的 SA 和数据包类型之间添加 4 个字节的 QTag 前缀字段，用于获取标志的 MAC 帧。前 2 个字节固定为 0x8100，用于识别 QTag 前缀的存在；后两个字节内容分别为 3 个位的用户优先级、 1 个位的标准格式指示符(CFI)和一个 12 位的 VLAN 标识符。



![lwip.png](https://z4a.net/images/2024/02/20/lwip.png)

lwip中数据接收流程









#### 4.6.1 地址转换

大端模式和小端模式

0x12345678

如果存储这个4 bytes的数据时，低位字节 0x78放到存储介质的低地址 ，高位字节0x12放到存储介质的高地址，就是**小端模式**。

相反的，低位字节0x78放到了存储的高地址，高位字节放到了存储介质的低地址，就是**大端模式**

常见的字节序

一般**操作系统**都是小端，而**通信协议**都是大端。
 **CPU字节序**：
 Big Endian : PowerPC、IBM、Sun
 Little Endian : x86、DEC, riscv
 ARM既可以工作在大端模式，也可以工作在小端模式。
 **文件字节序**：
 GIF – Little Endian
 JPEG – Big Endian



htons()、htonl()、ntohl()、ntohs()函数

从软件的角度上看，不同端模式的处理器进行**数据传递时必须要考虑端模式的不同**。如进行网络数据传递时，必须要考虑端模式的转换。以下几个函数用于大小端字节序的转换：

```c
#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换   
#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换   
#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换   
#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换  
```

其中互联网使用的**网络字节顺序采用大端模式进行编址**，而**主机字节顺序根据处理器的不同而不同**，如PowerPC处理器使用大端模式，而Pentuim处理器使用小端模式。
 大端模式处理器的字节序到网络字节序不需要转换，而**小端模式处理器的字节序到网络字节必须要进行转换**。 **不过为了移植性，在转换成网络字节序时，最好都使用htons()或htonl()函数**。

1） 把ip地址转化为用于网络传输的二进制数值

```c
int inet_aton(const char *cp, struct in_addr *inp);
```

inet_aton() 转换网络主机地址ip(如192.168.1.10)为二进制数值，并存储在struct in_addr结构中，即第二个参数*inp,函数返回非0表示cp主机有地有效，返回0表示主机地址无效。（这个转换完后不能用于网络传输，还需要调用htons或htonl函数才能将主机字节顺序转化为网络字节顺序）

```c
in_addr_t inet_addr(const char *cp);
```

inet_addr函数转换网络主机地址（如192.168.1.10)为网络字节序二进制值，如果参数char *cp无效，函数返回-1(INADDR_NONE),这个函数在处理地址为255.255.255.255时也返回－1,255.255.255.255是一个有效的地址，不过inet_addr无法处理;



2）将网络传输的二进制数值转化为成点分十进制的ip地址

```c
char *inet_ntoa(struct in_addr in);
```

inet_ntoa 函数转换网络字节排序的地址为标准的ASCII以点分开的地址,该函数返回指向点分开的字符串地址（如192.168.1.10)的指针，该字符串的空间为静态分配的，这意味着在第二次调用该函数时，上一次调用将会被重写（复盖），所以如果需要保存该串最后复制出来自己管理！

```c
#include <stdio.h>   
#include <sys/socket.h>   
#include <netinet/in.h>   
#include <arpa/inet.h>   
#include <string.h>   
int main()   
{   
	struct in_addr addr1,addr2;   
	ulong l1,l2;   
	l1= inet_addr("192.168.0.74");   
	l2 = inet_addr("211.100.21.179");   
	memcpy(&addr1, &l1, 4);   
	memcpy(&addr2, &l2, 4);   
	printf("%s : %s\n", inet_ntoa(addr1), inet_ntoa(addr2)); //注意这一句的运行结果   
	printf("%s\n", inet_ntoa(addr1));   
	printf("%s\n", inet_ntoa(addr2));  
	return 0;   
}
```

> 运行结果：
>
> 192.168.0.74 : 192.168.0.74
> 192.168.0.74
> 211.100.21.179

3）网路地址转化函数inet_pton和inet_ntop

这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。

```c
#include <arpe/inet.h>
int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1

const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
```

1）这两个函数的family参数既可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.
（2）第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.

（3）inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达式（strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。



#### 4.6.2 根据lwip的源码来看tcp建立连接过程中的三次握手

lwip的一些缩写

PCB  *protocol control block*



**linux下tcp三次握手和四次挥手**

> TCP 三次握手，其实就是建立一个 TCP 连接。客户端与服务器交互需要 3 个数据包。
>
> **作用：**确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。
>
> 
>
> 三次握手
>
> 第一次握手：客户端发送 SYN 报文，并进入 SYN_SENT 状态，等待服务器的确认；
>
> 第二次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；
>
> 第三次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。
>
> 
>
> 四次挥手
>
> 第一次挥手。客户端发起 FIN 包（FIN = 1）,客户端进入 FIN_WAIT_1 状态。TCP 规定，即使 FIN 包不携带数据，也要消耗一个序号第二次挥手。服务器端收到 FIN 包，发出确认包 ACK（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 CLOSE_WAIT 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 ACK 后，进入了 FIN_WAIT_2 状态。
>
> 第三次挥手。服务器端数据发送完毕后，向客户端发送 FIN 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 LAST_ACK 状态。
>
> 第四次挥手。客户端收到服务器的 FIN 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 TIME_WAIT 状态。注意此时 TCP 连接还没有释放，必须经过 2*MSL 后，才进入 CLOSED 状态。而服务器端收到客户端的确认包 ACK 后就进入了 CLOSED 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。



状态机：12种

1. CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）

2. LISTEN：等待从任何远端TCP 和端口的连接请求。

3. SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。

4. SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。

5. ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。

6. FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。

7. FIN_WAIT_2：等待远端TCP 的连接终止请求。

8. CLOSE_WAIT：等待本地用户的连接终止请求。

9. CLOSING状态：等待远端TCP 的连接终止请求确认。

客户端发送了FIN，但是没有收到服务器的ACK，却收到了服务器的FIN，这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。

10. LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）

11. TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。

12. TIME_WAIT 两个存在的理由：•可靠的实现tcp全双工连接的终止；•允许老的重复分节在网络中消逝。


​    

    **状态机切换，连接时：**
    
    1.一开始，建立连接之前服务器和客户端的状态都为CLOSED；
    
    2.服务器创建socket后开始监听，变为LISTEN状态；
    
    3.客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT；
    
    4.服务器收到客户端的报文后向客户端发送ACK和SYN报文  此时服务器的状态变为SYN_RCVD；
    
    5.然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED；
    
    6.服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立！


​    
​    

    **断开连接**
    
    1.客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1；
    
    2.服务器收到FIN后向客户端发送ACK，服务器的状态围边CLOSE_WAIT；
    
    3.客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送；
    
    4.直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态；
    
    5.客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态；
    
    6.再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。
    
    至此，还有一个状态没有出来：CLOSING状态。
    ————————————————
    
                                版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
    
    原文链接：https://blog.csdn.net/qq_51577576/article/details/121426400

   TCP状态转移图

![tcp.png](https://z4a.net/images/2024/02/22/tcp.png)





 TCP 三次握手与四次挥手的经典图（来自《TCP/IP详解卷1》）

![tcp.png](https://z4a.net/images/2024/02/19/tcp.png)

使用 nc 连接到 tcp server上（ip地址：192.168.1.102， 端口号：402）

```
nc -v 192.168.1.102 402
```

使用tcpdump命令查看连接过程

```
tcpdump -A -vv -i any -S host 192.168.1.102
```



```
(base) root@PC-202010131037:test_socket# tcpdump -A -vv -i any -S host 192.168.1.102
tcpdump: data link type LINUX_SLL2
tcpdump: listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes
17:11:19.476050 eth0  Out IP (tos 0x0, ttl 64, id 18266, offset 0, flags [DF], proto TCP (6), length 60)
    172.26.138.17.46604 > PC-202010131037.402: Flags [S], cksum 0xf868 (incorrect -> 0x28b2), seq 1494539820, win 64240, options [mss 1460,sackOK,TS val 1410001208 ecr 0,nop,wscale 7], length 0
E..<GZ@.@..'.......f....Y..,.........h.........
T
.8........
17:11:19.476290 eth0  In  IP (tos 0x0, ttl 127, id 4418, offset 0, flags [DF], proto TCP (6), length 52)
    PC-202010131037.402 > 172.26.138.17.46604: Flags [S.], cksum 0x81b8 (correct), seq 4262727156, ack 1494539821, win 65535, options [mss 65495,nop,wscale 8,nop,nop,sackOK], length 0
E..4.B@....G...f............Y..-....................
17:11:19.476321 eth0  Out IP (tos 0x0, ttl 64, id 18267, offset 0, flags [DF], proto TCP (6), length 40)
    172.26.138.17.46604 > PC-202010131037.402: Flags [.], cksum 0xf854 (incorrect -> 0xbab9), seq 1494539821, ack 4262727157, win 502, length 0
E..(G[@.@..:.......f....Y..-....P....T..
```



四次挥手：

```
17:13:34.782025 eth0  Out IP (tos 0x0, ttl 64, id 18268, offset 0, flags [DF], proto TCP (6), length 40)
    172.26.138.17.46604 > PC-202010131037.402: Flags [F.], cksum 0xf854 (incorrect -> 0xbab8), seq 1494539821, ack 4262727157, win 502, length 0
E..(G\@.@..9.......f....Y..-....P....T..
17:13:34.782224 eth0  In  IP (tos 0x0, ttl 127, id 4419, offset 0, flags [DF], proto TCP (6), length 40)
    PC-202010131037.402 > 172.26.138.17.46604: Flags [.], cksum 0x9c9a (correct), seq 4262727157, ack 1494539822, win 8212, length 0
E..(.C@....R...f............Y...P. .....
17:13:34.784395 eth0  In  IP (tos 0x0, ttl 127, id 4420, offset 0, flags [DF], proto TCP (6), length 40)
    PC-202010131037.402 > 172.26.138.17.46604: Flags [F.], cksum 0x9c99 (correct), seq 4262727157, ack 1494539822, win 8212, length 0
E..(.D@....Q...f............Y...P. .....
17:13:34.784409 eth0  Out IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 40)
    172.26.138.17.46604 > PC-202010131037.402: Flags [.], cksum 0xbab7 (correct), seq 1494539822, ack 4262727158, win 502, length 0
E..(..@.@.B........f....Y.......P.......

```



我们根据下面的测试程序来看lwip的代码流程

```
int tcp_demo_client_test(int n, char **arvg)
{
	int fd, result;
	struct sockaddr_in sock_addr;

	if (arvg[1]) {
		ip_addr = arvg[1];
	} else {
		ip_addr = "192.168.1.102";
	}

	sock_addr.sin_family = AF_INET;
	sock_addr.sin_port = htons(402);
	sock_addr.sin_addr.s_addr = inet_addr(ip_addr);

	fd = lwip_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (fd < 0) {
		return -1;
	}
	result = lwip_connect(fd, (struct sockaddr *)&sock_addr,
			      sizeof(sock_addr));
	printf("fd = %d connect %s:%d, result:%d\r\n", fd,
	       inet_ntoa(sock_addr.sin_addr), lwip_htons(sock_addr.sin_port),
	       result);
	
	
}
```



首先是 lwip_socket

```

int
lwip_socket(int domain, int type, int protocol)
{
  struct netconn *conn;
  int i;

  LWIP_UNUSED_ARG(domain); /* @todo: check this */

  /* create a netconn */
  switch (type) {
    case SOCK_RAW:
      conn = netconn_new_with_proto_and_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_RAW),
             (u8_t)protocol, DEFAULT_SOCKET_EVENTCB);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
      break;
    case SOCK_DGRAM:
      conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain,
                                       ((protocol == IPPROTO_UDPLITE) ? NETCONN_UDPLITE : NETCONN_UDP)),
                                       DEFAULT_SOCKET_EVENTCB);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
#if LWIP_NETBUF_RECVINFO
      if (conn) {
        /* netconn layer enables pktinfo by default, sockets default to off */
        conn->flags &= ~NETCONN_FLAG_PKTINFO;
      }
#endif /* LWIP_NETBUF_RECVINFO */
      break;
    case SOCK_STREAM:
      conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), DEFAULT_SOCKET_EVENTCB);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                  domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\r\n",
                                  domain, type, protocol));
      set_errno(EINVAL);
      return -1;
  }

  if (!conn) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\r\n"));
    set_errno(ENOBUFS);
    return -1;
  }

  i = alloc_socket(conn, 0);

  if (i == -1) {
    netconn_delete(conn);
    set_errno(ENFILE);
    return -1;
  }
  conn->socket = i;
  done_socket(&sockets[i - LWIP_SOCKET_OFFSET]);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
}
```



```

conn = netconn_new_with_callback(DOMAIN_TO_NETCONN_TYPE(domain, NETCONN_TCP), DEFAULT_SOCKET_EVENTCB);


struct netconn *
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  struct netconn *conn;
  API_MSG_VAR_DECLARE(msg);
  API_MSG_VAR_ALLOC_RETURN_NULL(msg);

  conn = netconn_alloc(t, callback);
  if (conn != NULL) {
    err_t err;

    API_MSG_VAR_REF(msg).msg.n.proto = proto;
    API_MSG_VAR_REF(msg).conn = conn;
    err = netconn_apimsg(lwip_netconn_do_newconn, &API_MSG_VAR_REF(msg));
    if (err != ERR_OK) {
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */
#if !LWIP_NETCONN_SEM_PER_THREAD
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
      sys_sem_free(&conn->op_completed);
#endif /* !LWIP_NETCONN_SEM_PER_THREAD */
      sys_mbox_free(&conn->recvmbox);
      memp_free(MEMP_NETCONN, conn);
      API_MSG_VAR_FREE(msg);
      return NULL;
    }
  }
  API_MSG_VAR_FREE(msg);
  return conn;
}

```

如果是 IPPROTO_TCP ，主要就是调用 tcp_alloc 申请了一个tcp 的pcb结构，setup_tcp 设置这个tcp的pcb结构



```

/**
 * Allocate a new socket for a given netconn.
 *
 * @param newconn the netconn for which to allocate a socket
 * @param accepted 1 if socket has been created by accept(),
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
  int i;
  SYS_ARCH_DECL_PROTECT(lev);
  LWIP_UNUSED_ARG(accepted);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
    if (!sockets[i].conn) {
#if LWIP_NETCONN_FULLDUPLEX
      if (sockets[i].fd_used) {
        SYS_ARCH_UNPROTECT(lev);
        continue;
      }
      sockets[i].fd_used    = 1;
      sockets[i].fd_free_pending = 0;
#endif
      sockets[i].conn       = newconn;
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
      sockets[i].lastdata.pbuf = NULL;
#if LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL
      LWIP_ASSERT("sockets[i].select_waiting == 0", sockets[i].select_waiting == 0);
      sockets[i].rcvevent   = 0;
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      // sockets[i].sendevent  = (NETCONNTYPE_GROUP(newconn->type) == NETCONN_TCP ? (accepted != 0) : 1);
      sockets[i].sendevent = 1;
      sockets[i].errevent = 0;
#endif /* LWIP_SOCKET_SELECT || LWIP_SOCKET_POLL */

#ifdef OS_USING_IO_MULTIPLEXING
            sockets[i].req = OS_NULL;
#endif

      return i + LWIP_SOCKET_OFFSET;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
}
```



我们手动将 sockets[i].sendevent 设置成1，通过注释看到“TCP sendbuf is empty, but the socket is not yet writable until connected”。socket 连接之前是不可写的。如果将这里写成1，会有什么问题呢？

可以想到的是，用户可能会调用 lwip_write()去写缓存导致异常。

lwip_write()的流程中，会通过tcp_write_checks来检查socket的状态。可以看到当状态不是SYN_SENT（表示发送了建立连接的SYN报文，拔掉网线后，网络状态不通，不会发送SYN报文，pcb状态还是初始化状态0），ESTABLISHED等状态，send会直接退出，不会走后面的流程。

```

/** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
 *
 * @param pcb the tcp pcb to check for
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);

  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
                len, pcb->snd_buf));
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
    return ERR_MEM;
  }

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
                pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    tcp_set_flags(pcb, TF_NAGLEMEMERR);
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
                pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
                pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
}
```



然后是 lwip_connect

```

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  struct lwip_sock *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock) {
    return -1;
  }

  if (!SOCK_ADDR_TYPE_MATCH_OR_UNSPEC(name, sock)) {
    /* sockaddr does not match socket type (IPv4/IPv6) */
    sock_set_errno(sock, err_to_errno(ERR_VAL));
    done_socket(sock);
    return -1;
  }

  LWIP_UNUSED_ARG(namelen);
  if (name->sa_family == AF_UNSPEC) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\r\n", s));
    err = netconn_disconnect(sock->conn);
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    /* check size, family and alignment of 'name' */
    LWIP_ERROR("lwip_connect: invalid address", IS_SOCK_ADDR_LEN_VALID(namelen) &&
               IS_SOCK_ADDR_TYPE_VALID_OR_UNSPEC(name) && IS_SOCK_ADDR_ALIGNED(name),
               sock_set_errno(sock, err_to_errno(ERR_ARG)); done_socket(sock); return -1;);

    SOCKADDR_TO_IPADDR_PORT(name, &remote_addr, remote_port);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print_val(SOCKETS_DEBUG, remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\r\n", remote_port));

#if LWIP_IPV4 && LWIP_IPV6
    /* Dual-stack: Unmap IPv4 mapped IPv6 addresses */
    if (IP_IS_V6_VAL(remote_addr) && ip6_addr_isipv4mappedipv6(ip_2_ip6(&remote_addr))) {
      unmap_ipv4_mapped_ipv6(ip_2_ip4(&remote_addr), ip_2_ip6(&remote_addr));
      IP_SET_TYPE_VAL(remote_addr, IPADDR_TYPE_V4);
    }
#endif /* LWIP_IPV4 && LWIP_IPV6 */

    err = netconn_connect(sock->conn, &remote_addr, remote_port);
  }

  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\r\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
    done_socket(sock);
    return -1;
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\r\n", s));
  sock_set_errno(sock, 0);
  done_socket(sock);
  return 0;
}
```

调用 netconn_connect 发起连接

```
/**
 * @ingroup netconn_common
 * Connect a netconn to a specific remote IP address and port.
 *
 * @param conn the netconn to connect
 * @param addr the remote IP address to connect to
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port)
{
  API_MSG_VAR_DECLARE(msg);
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);

#if LWIP_IPV4
  /* Don't propagate NULL pointer (IP_ADDR_ANY alias) to subsequent functions */
  if (addr == NULL) {
    addr = IP4_ADDR_ANY;
  }
#endif /* LWIP_IPV4 */

  API_MSG_VAR_ALLOC(msg);
  API_MSG_VAR_REF(msg).conn = conn;
  API_MSG_VAR_REF(msg).msg.bc.ipaddr = API_MSG_VAR_REF(addr);
  API_MSG_VAR_REF(msg).msg.bc.port = port;
  err = netconn_apimsg(lwip_netconn_do_connect, &API_MSG_VAR_REF(msg));
  API_MSG_VAR_FREE(msg);

  return err;
}
```



```

/**
 * Connect a pcb contained inside a netconn
 * Called from netconn_connect.
 *
 * @param m the api_msg pointing to the connection and containing
 *          the IP address and port to connect to
 */
void
lwip_netconn_do_connect(void *m)
{
  struct api_msg *msg = (struct api_msg *)m;
  err_t err;

  if (msg->conn->pcb.tcp == NULL) {
    /* This may happen when calling netconn_connect() a second time */
    err = ERR_CLSD;
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        err = raw_connect(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
        break;
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        err = udp_connect(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        /* Prevent connect while doing any other action. */
        if (msg->conn->state == NETCONN_CONNECT) {
          err = ERR_ALREADY;
        } else if (msg->conn->state != NETCONN_NONE) {
          err = ERR_ISCONN;
        } else {
          setup_tcp(msg->conn);
          err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
                            msg->msg.bc.port, lwip_netconn_do_connected);
          if (err == ERR_OK) {
            u8_t non_blocking = netconn_is_nonblocking(msg->conn);
            msg->conn->state = NETCONN_CONNECT;
            SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
            if (non_blocking) {
              err = ERR_INPROGRESS;
            } else {
              msg->conn->current_msg = msg;
              /* sys_sem_signal() is called from lwip_netconn_do_connected (or err_tcp()),
                 when the connection is established! */
#if LWIP_TCPIP_CORE_LOCKING
              LWIP_ASSERT("state!", msg->conn->state == NETCONN_CONNECT);
              UNLOCK_TCPIP_CORE();
              sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
              LOCK_TCPIP_CORE();
              LWIP_ASSERT("state!", msg->conn->state != NETCONN_CONNECT);
#endif /* LWIP_TCPIP_CORE_LOCKING */
              return;
            }
          }
        }
        break;
#endif /* LWIP_TCP */
      default:
        LWIP_ERROR("Invalid netconn type", 0, do {
          err = ERR_VAL;
        } while (0));
        break;
    }
  }
  msg->err = err;
  /* For all other protocols, netconn_connect() calls netconn_apimsg(),
     so use TCPIP_APIMSG_ACK() here. */
  TCPIP_APIMSG_ACK(msg);
}
```





```

/**
 * @ingroup tcp_raw
 * Connects to another host. The function given as the "connected"
 * argument will be called when the connection has been established.
 *  Sets up the pcb to connect to the remote host and sends the
 * initial SYN segment which opens the connection.
 *
 * The tcp_connect() function returns immediately; it does not wait for
 * the connection to be properly setup. Instead, it will call the
 * function specified as the fourth argument (the "connected" argument)
 * when the connection is established. If the connection could not be
 * properly established, either because the other host refused the
 * connection or because the other host didn't answer, the "err"
 * callback function of this pcb (registered with tcp_err, see below)
 * will be called.
 *
 * The tcp_connect() function can return ERR_MEM if no memory is
 * available for enqueueing the SYN segment. If the SYN indeed was
 * enqueued successfully, the tcp_connect() function returns ERR_OK.
 *
 * @param pcb the tcp_pcb used to establish the connection
 * @param ipaddr the remote ip address to connect to
 * @param port the remote tcp port to connect to
 * @param connected callback function to call when connected (on error,
                    the err calback will be called)
 * @return ERR_VAL if invalid arguments are given
 *         ERR_OK if connect request has been sent
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
            tcp_connected_fn connected)
{
  struct netif *netif = NULL;
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ASSERT_CORE_LOCKED();

  LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
  LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  ip_addr_set(&pcb->remote_ip, ipaddr);
  pcb->remote_port = port;

  if (pcb->netif_idx != NETIF_NO_INDEX) {
    netif = netif_get_by_index(pcb->netif_idx);
  } else {
    /* check if we have a route to the remote host */
    netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
  }
  if (netif == NULL) {
    /* Don't even try to send a SYN packet if we have no route since that will fail. */
    return ERR_RTE;
  }

  /* check if local IP has been assigned to pcb, if not, get one */
  if (ip_addr_isany(&pcb->local_ip)) {
    const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, ipaddr);
    if (local_ip == NULL) {
      return ERR_RTE;
    }
    ip_addr_copy(pcb->local_ip, *local_ip);
  }

#if LWIP_IPV6 && LWIP_IPV6_SCOPES
  /* If the given IP address should have a zone but doesn't, assign one now.
   * Given that we already have the target netif, this is easy and cheap. */
  if (IP_IS_V6(&pcb->remote_ip) &&
      ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST)) {
    ip6_addr_assign_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST, netif);
  }
#endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */

  old_local_port = pcb->local_port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
    if (pcb->local_port == 0) {
      return ERR_BUF;
    }
  } else {
#if SO_REUSE
    if (ip_get_option(pcb, SOF_REUSEADDR)) {
      /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
         now that the 5-tuple is unique. */
      struct tcp_pcb *cpcb;
      int i;
      /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
      for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
        for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
          if ((cpcb->local_port == pcb->local_port) &&
              (cpcb->remote_port == port) &&
              ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
              ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
            /* linux returns EISCONN here, but ERR_USE should be OK for us */
            return ERR_USE;
          }
        }
      }
    }
#endif /* SO_REUSE */
  }

  iss = tcp_next_iss(pcb);
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
  pcb->snd_wl2 = iss - 1;
  pcb->snd_lbb = iss - 1;
  /* Start with a window that does not need scaling. When window scaling is
     enabled and used, the window is enlarged when both sides agree on scaling. */
  pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = INITIAL_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
#if LWIP_CALLBACK_API
  pcb->connected = connected;
#else /* LWIP_CALLBACK_API */
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
  if (ret == ERR_OK) {
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    }
    TCP_REG_ACTIVE(pcb);
    MIB2_STATS_INC(mib2.tcpactiveopens);

    tcp_output(pcb);
  }
  return ret;
}
```



tcp_connect中，在 tcp_enqueue_flags 完成了 SYN TCP包的部分组包操作 ，然后设置 pcb->state 为 SYN_SENT，再将这个数据通过tcp_output发送出去。

```
tcp_output -> tcp_output_segment -> ip_output_if -> ... -> netif->output(netif, p, dest) -> etharp_output -> ethernet_output -> netif->linkoutput
```



 到这里，TCP建立连接的第一次握手 SYN的流程就结束了。



第二次握手，服务端发送SYN+ACK给发起连接的一方。

设备的网卡驱动收到数据，触发中断，最终将接收到网络数据包发给了 os_lwip_input 进行处理，流程如下：

```
os_lwip_input() -> netif->input() -> tcpip_input() -> tcpip_inpkt()
```

```
/**
 * Pass a received packet to tcpip_thread for input processing
 *
 * @param p the received packet
 * @param inp the network interface on which the packet was received
 * @param input_fn input function to call
 */
err_t
tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn)
{
#if LWIP_TCPIP_CORE_LOCKING_INPUT
  err_t ret;
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_inpkt: PACKET %p/%p\n", (void *)p, (void *)inp));
  LOCK_TCPIP_CORE();
  ret = input_fn(p, inp);
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  LWIP_ASSERT("Invalid mbox", sys_mbox_valid_val(tcpip_mbox));

  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == NULL) {
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
  msg->msg.inp.p = p;
  msg->msg.inp.netif = inp;
  msg->msg.inp.input_fn = input_fn;
  if (sys_mbox_trypost(&tcpip_mbox, msg) != ERR_OK) {
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    return ERR_MEM;
  }
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
```



tcpip_inpkt 将接收数据的消息封装到msgbox，发送给tcpip_thread 任务处理。

```
/**
 * The main lwIP thread. This thread has exclusive access to lwIP core functions
 * (unless access to them is not locked). Other threads communicate with this
 * thread using message boxes.
 *
 * It also starts all the timers to make sure they are running in the right
 * thread context.
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  LWIP_MARK_TCPIP_THREAD();

  LOCK_TCPIP_CORE();
  if (tcpip_init_done != NULL) {
    tcpip_init_done(tcpip_init_done_arg);
  }

  while (1) {                          /* MAIN Loop */
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    TCPIP_MBOX_FETCH(&tcpip_mbox, (void **)&msg);
    if (msg == NULL) {
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: NULL\n"));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      continue;
    }
    tcpip_thread_handle_msg(msg);
  }
}

```

```

/* Handle a single tcpip_msg
 * This is in its own function for access by tests only.
 */
static void
tcpip_thread_handle_msg(struct tcpip_msg *msg)
{
  switch (msg->type) {
#if !LWIP_TCPIP_CORE_LOCKING
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.api_msg.function(msg->msg.api_msg.msg);
      break;
    case TCPIP_MSG_API_CALL:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API CALL message %p\n", (void *)msg));
      msg->msg.api_call.arg->err = msg->msg.api_call.function(msg->msg.api_call.arg);
      sys_sem_signal(msg->msg.api_call.sem);
      break;
#endif /* !LWIP_TCPIP_CORE_LOCKING */

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
      if (msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif) != ERR_OK) {
        pbuf_free(msg->msg.inp.p);
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      break;
#endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */

#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;
#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
      break;

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      break;
  }
}
```

会调用 msg->msg.inp.input_fn(msg->msg.inp.p, msg->msg.inp.netif) 来处理，input_fn 是 tcpip_inpkt 的第三个参数，对于ipv4是ip4_input.



```
/**
 * This function is called by the network interface device driver when
 * an IP packet is received. The function does the basic checks of the
 * IP header such as packet size being at least larger than the header
 * size etc. If the packet was not destined for us, the packet is
 * forwarded (using ip_forward). The IP checksum is always checked.
 *
 * Finally, the packet is sent to the upper layer protocol input function.
 *
 * @param p the received IP packet (p->payload points to IP header)
 * @param inp the netif on which this packet was received
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip4_input(struct pbuf *p, struct netif *inp)
```



ip4_input 经过一系列的处理，拆包等，调度到 tcp_input

```
/**
 * The initial input processing of TCP. It verifies the TCP header, demultiplexes
 * the segment between the PCBs and passes it on to tcp_process(), which implements
 * the TCP finite state machine. This function is called by the IP layer (in
 * ip_input()).
 *
 * @param p received TCP segment to process (p->payload pointing to the TCP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
```

通过tcp_process 对这个收到的tcp包进行处理，检查ack是不是正确等

```

/**
 * Implements the TCP state machine. Called by tcp_input. In some
 * states tcp_receive() is called to receive data. The tcp_seg
 * argument will be freed by the caller (tcp_input()) unless the
 * recv_data pointer in the pcb is set.
 *
 * @param pcb the tcp_pcb for which a segment arrived
 *
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  err_t err;

  err = ERR_OK;

  LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
      /* "In the SYN-SENT state (a RST received in response to an initial SYN),
          the RST is acceptable if the ACK field acknowledges the SYN." */
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      /* "In all states except SYN-SENT, all reset (RST) segments are validated
          by checking their SEQ-fields." */
      if (seqno == pcb->rcv_nxt) {
        acceptable = 1;
      } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
                                  pcb->rcv_nxt + pcb->rcv_wnd)) {
        /* If the sequence number is inside the window, we send a challenge ACK
           and wait for a re-send with matching sequence number.
           This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
           (RST spoofing attack), which is present in RFC 793 RST handling. */
        tcp_ack_now(pcb);
      }
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
      tcp_clear_flags(pcb, TF_ACK_DELAY);
      return ERR_RST;
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                                    seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
                              seqno, pcb->rcv_nxt));
      return ERR_OK;
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    return ERR_OK;
  }

  if ((pcb->flags & TF_RXCLOSED) == 0) {
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
  }
  pcb->keep_cnt_sent = 0;
  pcb->persist_probe = 0;

  tcp_parseopt(pcb);

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
    case SYN_SENT:
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
                                    pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
      /* received SYN ACK with expected sequence number? */
      if ((flags & TCP_ACK) && (flags & TCP_SYN)
          && (ackno == pcb->lastack + 1)) {
        pcb->rcv_nxt = seqno + 1;
        pcb->rcv_ann_right_edge = pcb->rcv_nxt;
        pcb->lastack = ackno;
        pcb->snd_wnd = tcphdr->wnd;
        pcb->snd_wnd_max = pcb->snd_wnd;
        pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
        pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
        pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

        pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
        LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
                                     " ssthresh %"TCPWNDSIZE_F"\n",
                                     pcb->cwnd, pcb->ssthresh));
        LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
        --pcb->snd_queuelen;
        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
        rseg = pcb->unacked;
        if (rseg == NULL) {
          /* might happen if tcp_output fails in tcp_rexmit_rto()
             in which case the segment is on the unsent list */
          rseg = pcb->unsent;
          LWIP_ASSERT("no segment to free", rseg != NULL);
          pcb->unsent = rseg->next;
        } else {
          pcb->unacked = rseg->next;
        }
        tcp_seg_free(rseg);

        /* If there's nothing left to acknowledge, stop the retransmit
           timer, otherwise reset it to start again */
        if (pcb->unacked == NULL) {
          pcb->rtime = -1;
        } else {
          pcb->rtime = 0;
          pcb->nrtx = 0;
        }

        /* Call the user specified function to call when successfully
         * connected. */
        TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
        if (err == ERR_ABRT) {
          return ERR_ABRT;
        }
        tcp_ack_now(pcb);
      }
      /* received ACK? possibly a half-open connection */
      else if (flags & TCP_ACK) {
        /* send a RST to bring the other side in a non-synchronized state. */
        tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
        /* Resend SYN immediately (don't wait for rto timeout) to establish
          connection faster, but do not send more SYNs than we otherwise would
          have, or we might get caught in a loop on loopback interfaces. */
        if (pcb->nrtx < TCP_SYNMAXRTX) {
          pcb->rtime = 0;
          tcp_rexmit_rto(pcb);
        }
      }
      break;
    case SYN_RCVD:
      if (flags & TCP_ACK) {
        /* expected ACK number? */
        if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
          pcb->state = ESTABLISHED;
          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
          if (pcb->listener == NULL) {
            /* listen pcb might be closed by now */
            err = ERR_VAL;
          } else
#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
          {
#if LWIP_CALLBACK_API
            LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
#endif
            tcp_backlog_accepted(pcb);
            /* Call the accept function. */
            TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
          }
          if (err != ERR_OK) {
            /* If the accept function returns with an error, we abort
             * the connection. */
            /* Already aborted? */
            if (err != ERR_ABRT) {
              tcp_abort(pcb);
            }
            return ERR_ABRT;
          }
          /* If there was any data contained within this ACK,
           * we'd better pass it on to the application as well. */
          tcp_receive(pcb);

          /* Prevent ACK for SYN to generate a sent event */
          if (recv_acked != 0) {
            recv_acked--;
          }

          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
                                       " ssthresh %"TCPWNDSIZE_F"\n",
                                       pcb->cwnd, pcb->ssthresh));

          if (recv_flags & TF_GOT_FIN) {
            tcp_ack_now(pcb);
            pcb->state = CLOSE_WAIT;
          }
        } else {
          /* incorrect ACK number, send RST */
          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
        }
      } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
        /* Looks like another copy of the SYN - retransmit our SYN-ACK */
        tcp_rexmit(pcb);
      }
      break;
    case CLOSE_WAIT:
    /* FALLTHROUGH */
    case ESTABLISHED:
      tcp_receive(pcb);
      if (recv_flags & TF_GOT_FIN) { /* passive close */
        tcp_ack_now(pcb);
        pcb->state = CLOSE_WAIT;
      }
      break;
    case FIN_WAIT_1:
      tcp_receive(pcb);
      if (recv_flags & TF_GOT_FIN) {
        if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
            pcb->unsent == NULL) {
          LWIP_DEBUGF(TCP_DEBUG,
                      ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
          tcp_ack_now(pcb);
          tcp_pcb_purge(pcb);
          TCP_RMV_ACTIVE(pcb);
          pcb->state = TIME_WAIT;
          TCP_REG(&tcp_tw_pcbs, pcb);
        } else {
          tcp_ack_now(pcb);
          pcb->state = CLOSING;
        }
      } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
                 pcb->unsent == NULL) {
        pcb->state = FIN_WAIT_2;
      }
      break;
    case FIN_WAIT_2:
      tcp_receive(pcb);
      if (recv_flags & TF_GOT_FIN) {
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      }
      break;
    case CLOSING:
      tcp_receive(pcb);
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      }
      break;
    case LAST_ACK:
      tcp_receive(pcb);
      if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
        recv_flags |= TF_CLOSED;
      }
      break;
    default:
      break;
  }
  return ERR_OK;
}
```

退出tcp_process后，会调用 tcp_output(pcb) 发送ACK给 服务端，这就是第三次握手了。



电脑上的tcp server没有启动时，tcp_demo_client_test这个测试程序打印的log：

```
02-22 15:19:47:893  lwip_socket(PF_INET, SOCK_STREAM, 6) = 0
02-22 15:19:47:893  get socket fd = 0
02-22 15:19:47:893  lwip_connect(0, addr=192.168.1.103 port=402)
02-22 15:19:47:903  tcp_connect to port 402
02-22 15:19:47:903  tcp_enqueue_flags: queuelen: 0
02-22 15:19:47:904  tcp_enqueue_flags: queueing 6509:6510 (0x2)
02-22 15:19:47:915  tcp_enqueue_flags: 1 (after enqueued)
02-22 15:19:47:915  tcp_output: snd_wnd 8196, cwnd 1, wnd 1, effwnd 0, seq 6509, ack 6509
02-22 15:19:47:926  tcp_output: snd_wnd 8196, cwnd 1, wnd 1, effwnd 0, seq 6509, ack 6509, i 0
02-22 15:19:47:926  tcp_output_segment: rtseq 6509
02-22 15:19:47:926  tcp_output_segment: 6509:6509
02-22 15:19:47:926  ip4_output_if: e00
02-22 15:19:47:927  IP header:
02-22 15:19:47:936  +-------------------------------+
02-22 15:19:47:936  | 4 | 5 |  0x00 |        44     | (v, hl, tos, len)
02-22 15:19:47:937  +-------------------------------+
02-22 15:19:47:948  |       17      |000|       0   | (id, flags, offset)
02-22 15:19:47:948  +-------------------------------+
02-22 15:19:47:959  |  255  |    6  |    0x379f     | (ttl, proto, chksum)
02-22 15:19:47:959  +-------------------------------+
02-22 15:19:47:959  |  192  |  168  |    1  |  100  | (src)
02-22 15:19:47:959  +-------------------------------+
02-22 15:19:47:970  |  192  |  168  |    1  |  103  | (dest)
02-22 15:19:47:970  +-------------------------------+
02-22 15:19:47:970  ip4_output_if: call netif->output()
02-22 15:19:48:001  tcpip_thread: PACKET 101429b0
02-22 15:19:48:226  tcp_slowtmr: processing active pcb
02-22 15:19:48:715  tcp_slowtmr: processing active pcb
02-22 15:19:48:716  tcp_slowtmr: polling application
02-22 15:19:48:716  tcp_output: nothing to send (00000000)
02-22 15:19:48:740  tcp_output: snd_wnd 8196, cwnd 1, wnd 1, seg == NULL, ack 6509
02-22 15:19:49:238  tcp_slowtmr: processing active pcb
02-22 15:19:49:735  tcp_slowtmr: processing active pcb
02-22 15:19:49:735  tcp_slowtmr: polling application
02-22 15:19:49:735  tcp_output: nothing to send (00000000)
02-22 15:19:49:771  tcp_output: snd_wnd 8196, cwnd 1, wnd 1, seg == NULL, ack 6509
02-22 15:19:50:264  tcp_slowtmr: processing active pcb
02-22 15:19:50:752  tcp_slowtmr: processing active pcb
02-22 15:19:50:752  tcp_slowtmr: rtime 6 pcb->rto 6
02-22 15:19:50:752  tcp_slowtmr: cwnd 536 ssthresh 1072
02-22 15:19:50:763  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509
02-22 15:19:50:774  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509, i 0
02-22 15:19:50:774  tcp_output_segment: rtseq 6509
02-22 15:19:50:775  tcp_output_segment: 6509:6509
02-22 15:19:50:775  ip4_output_if: e00
02-22 15:19:50:775  IP header:
02-22 15:19:50:785  +-------------------------------+
02-22 15:19:50:785  | 4 | 5 |  0x00 |        44     | (v, hl, tos, len)
02-22 15:19:50:785  +-------------------------------+
02-22 15:19:50:796  |       18      |000|       0   | (id, flags, offset)
02-22 15:19:50:796  +-------------------------------+
02-22 15:19:50:796  |  255  |    6  |    0x379e     | (ttl, proto, chksum)
02-22 15:19:50:807  +-------------------------------+
02-22 15:19:50:807  |  192  |  168  |    1  |  100  | (src)
02-22 15:19:50:808  +-------------------------------+
02-22 15:19:50:820  |  192  |  168  |    1  |  103  | (dest)
02-22 15:19:50:820  +-------------------------------+
02-22 15:19:50:820  ip4_output_if: call netif->output()
02-22 15:19:50:820  tcp_slowtmr: polling application
02-22 15:19:50:859  tcp_output: nothing to send (00000000)
02-22 15:19:50:860  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:51:351  tcp_slowtmr: processing active pcb
02-22 15:19:51:842  tcp_slowtmr: processing active pcb
02-22 15:19:51:842  tcp_slowtmr: polling application
02-22 15:19:51:842  tcp_output: nothing to send (00000000)
02-22 15:19:51:871  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:52:386  tcp_slowtmr: processing active pcb
02-22 15:19:52:860  tcp_slowtmr: processing active pcb
02-22 15:19:52:860  tcp_slowtmr: polling application
02-22 15:19:52:860  tcp_output: nothing to send (00000000)
02-22 15:19:52:891  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:53:396  tcp_slowtmr: processing active pcb
02-22 15:19:53:879  tcp_slowtmr: processing active pcb
02-22 15:19:53:879  tcp_slowtmr: rtime 6 pcb->rto 6
02-22 15:19:53:879  tcp_slowtmr: cwnd 536 ssthresh 1072
02-22 15:19:53:891  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509
02-22 15:19:53:901  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509, i 0
02-22 15:19:53:901  tcp_output_segment: rtseq 6509
02-22 15:19:53:901  tcp_output_segment: 6509:6509
02-22 15:19:53:901  ip4_output_if: e00
02-22 15:19:53:901  IP header:
02-22 15:19:53:913  +-------------------------------+
02-22 15:19:53:913  | 4 | 5 |  0x00 |        44     | (v, hl, tos, len)
02-22 15:19:53:913  +-------------------------------+
02-22 15:19:53:924  |       19      |000|       0   | (id, flags, offset)
02-22 15:19:53:924  +-------------------------------+
02-22 15:19:53:924  |  255  |    6  |    0x379d     | (ttl, proto, chksum)
02-22 15:19:53:935  +-------------------------------+
02-22 15:19:53:935  |  192  |  168  |    1  |  100  | (src)
02-22 15:19:53:935  +-------------------------------+
02-22 15:19:53:946  |  192  |  168  |    1  |  103  | (dest)
02-22 15:19:53:946  +-------------------------------+
02-22 15:19:53:946  ip4_output_if: call netif->output()
02-22 15:19:53:946  tcp_slowtmr: polling application
02-22 15:19:53:989  tcp_output: nothing to send (00000000)
02-22 15:19:53:989  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:54:485  tcp_slowtmr: processing active pcb
02-22 15:19:54:969  tcp_slowtmr: processing active pcb
02-22 15:19:54:969  tcp_slowtmr: polling application
02-22 15:19:54:969  tcp_output: nothing to send (00000000)
02-22 15:19:55:000  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:55:495  tcp_slowtmr: processing active pcb
02-22 15:19:55:988  tcp_slowtmr: processing active pcb
02-22 15:19:55:988  tcp_slowtmr: polling application
02-22 15:19:55:988  tcp_output: nothing to send (00000000)
02-22 15:19:56:008  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:56:521  tcp_slowtmr: processing active pcb
02-22 15:19:57:007  tcp_slowtmr: processing active pcb
02-22 15:19:57:007  tcp_slowtmr: rtime 6 pcb->rto 6
02-22 15:19:57:007  tcp_slowtmr: cwnd 536 ssthresh 1072
02-22 15:19:57:019  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509
02-22 15:19:57:029  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509, i 0
02-22 15:19:57:029  tcp_output_segment: rtseq 6509
02-22 15:19:57:029  tcp_output_segment: 6509:6509
02-22 15:19:57:029  ip4_output_if: e00
02-22 15:19:57:029  IP header:
02-22 15:19:57:040  +-------------------------------+
02-22 15:19:57:040  | 4 | 5 |  0x00 |        44     | (v, hl, tos, len)
02-22 15:19:57:040  +-------------------------------+
02-22 15:19:57:051  |       20      |000|       0   | (id, flags, offset)
02-22 15:19:57:051  +-------------------------------+
02-22 15:19:57:051  |  255  |    6  |    0x379c     | (ttl, proto, chksum)
02-22 15:19:57:062  +-------------------------------+
02-22 15:19:57:062  |  192  |  168  |    1  |  100  | (src)
02-22 15:19:57:062  +-------------------------------+
02-22 15:19:57:073  |  192  |  168  |    1  |  103  | (dest)
02-22 15:19:57:073  +-------------------------------+
02-22 15:19:57:073  ip4_output_if: call netif->output()
02-22 15:19:57:073  tcp_slowtmr: polling application
02-22 15:19:57:109  tcp_output: nothing to send (00000000)
02-22 15:19:57:109  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:57:605  tcp_slowtmr: processing active pcb
02-22 15:19:58:095  tcp_slowtmr: processing active pcb
02-22 15:19:58:095  tcp_slowtmr: polling application
02-22 15:19:58:095  tcp_output: nothing to send (00000000)
02-22 15:19:58:119  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:58:547  tcpip_thread: PACKET 101429b0
02-22 15:19:58:631  tcp_slowtmr: processing active pcb
02-22 15:19:59:117  tcp_slowtmr: processing active pcb
02-22 15:19:59:117  tcp_slowtmr: polling application
02-22 15:19:59:117  tcp_output: nothing to send (00000000)
02-22 15:19:59:144  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:19:59:533  tcpip_thread: PACKET 101429b0
02-22 15:19:59:657  tcp_slowtmr: processing active pcb
02-22 15:20:00:138  tcp_slowtmr: processing active pcb
02-22 15:20:00:138  tcp_slowtmr: rtime 6 pcb->rto 6
02-22 15:20:00:138  tcp_slowtmr: cwnd 536 ssthresh 1072
02-22 15:20:00:149  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509
02-22 15:20:00:160  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, effwnd 0, seq 6509, ack 6509, i 0
02-22 15:20:00:160  tcp_output_segment: rtseq 6509
02-22 15:20:00:160  tcp_output_segment: 6509:6509
02-22 15:20:00:160  ip4_output_if: e00
02-22 15:20:00:160  IP header:
02-22 15:20:00:173  +-------------------------------+
02-22 15:20:00:173  | 4 | 5 |  0x00 |        44     | (v, hl, tos, len)
02-22 15:20:00:173  +-------------------------------+
02-22 15:20:00:182  |       21      |000|       0   | (id, flags, offset)
02-22 15:20:00:182  +-------------------------------+
02-22 15:20:00:183  |  255  |    6  |    0x379b     | (ttl, proto, chksum)
02-22 15:20:00:194  +-------------------------------+
02-22 15:20:00:194  |  192  |  168  |    1  |  100  | (src)
02-22 15:20:00:194  +-------------------------------+
02-22 15:20:00:205  |  192  |  168  |    1  |  103  | (dest)
02-22 15:20:00:206  +-------------------------------+
02-22 15:20:00:206  ip4_output_if: call netif->output()
02-22 15:20:00:206  tcp_slowtmr: polling application
02-22 15:20:00:232  tcp_output: nothing to send (00000000)
02-22 15:20:00:232  tcp_output: snd_wnd 8196, cwnd 536, wnd 536, seg == NULL, ack 6509
02-22 15:20:00:724  tcp_slowtmr: processing active pcb
02-22 15:20:00:725  tcp_slowtmr: max SYN retries reached
02-22 15:20:00:725  tcp_pcb_purge
02-22 15:20:00:725  tcp_pcb_purge: data left on ->unacked
02-22 15:20:00:734  lwip_connect(0) failed, err=-13
02-22 15:20:00:734  fd = 0 connect 192.168.1.103:402, result:-1
02-22 15:20:00:745  lwip_select(1, 1013ffe0, 1013ffd8, 1013ffd0, tvsec=5 tvusec=5)
02-22 15:20:00:746  lwip_selscan: fd=0 ready for reading
02-22 15:20:00:746  lwip_selscan: fd=0 ready for writing
02-22 15:20:00:758  lwip_selscan: fd=0 ready for exception
02-22 15:20:00:758  lwip_select: nready=3
02-22 15:20:00:758  fd = 0 select ready:3,r:1 w:1 e:1
02-22 15:20:00:758  fd = 0 select except is set: 1
02-22 15:20:00:758  lwip_close(0)
02-22 15:20:00:777  fd = 0 close result:0
```

#### 4.6.3 IPv4 首部格式

![IP.png](https://z4a.net/images/2024/02/22/IP.png)

#### 4.6.4 IPv6首部格式

IPv6报文有8个字段，固定大小为40字节，每一个IPv6数据包都必须包含报头，基本报头结构如下图所示：

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| Traffic Class |              Flow Label               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      PlayLoad Length          |  Next Header  |   Hop Limit   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Source                             |
|                            Address                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Destination                        |
|                            Address                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- Version：版本号，长度为4bit，对于IPv6，其值为6
- Traffic Class：流类别，长度为8bit，用于表示数据报的优先级，用于QoS
- Flow Label：流标签，长度为20bit，用于区分实时流量，不同的流标签+源地址可以唯一确定一条数据流
- PlayLoad Length：有效载荷长度，长度为16bit，指的是紧跟IPv6报头的数据包的其他部分（扩展报头和上层协议数据单元）。该字段只能表示最大长度为65535字节的有效载荷。如果长度超过这个值，该字段会置0，而有效载荷长度用逐跳选项扩展报头中的超大有效载荷选项来表示
- Next Header：下一个报头，长度为8bit，该字段定义了紧跟在IPv6报头后面的第一个扩展报头的类型，或者上层协议数据单元中的协议类型
- Hop Limit：跳数限制，长度为8bit，该字段类似于IPv4中的TTL字段，定义了IP数据包经过的最大跳数。
- Source Address：源地址，128bit，发送方的地址
- Destination Address：目的地址，128bit，接收方的地址

##### 4.6.4.1 IPv6地址规范

IPv6地址包含128比特，以16位为一组，每组以冒号“：”隔开，可分为8组，每组以4位十六进制方式表示，以下为合法的IPv6地址：“2001:0DB8:02de:0000:0000:0000:0000:0e13”,同时IPv6还支持省略规则：

规则1：每项数字前导0可省略，省略后前导数字仍为0的可继续，上述的地址可等效为：“2001:DB8:2de:0:0:0:0:e13”

规则2：可用双冒号“::”来表示一组或多组的0，但只可出现一次，上述的地址可等效为："2001:DB8:2de::e13"



前四个数字来区分自己的网址是不是公网网址。公网网址就是可以访问其它ipv6的网址。

| 公网ipv6 | 运营商 |
| -------- | ------ |
| 240e     | 电信   |
| 2409     | 移动   |
| 2408     | 联通   |

| 非公网ipv6 | 意义                                                         |
| ---------- | ------------------------------------------------------------ |
| ::1        | loopback 地址，表示本机，等价于 IPv4 中的127.0.0.1           |
| fe80::/10  | 所谓的 link local 地址段，只在同一链路上有效，不能跨网段通信，类似于 IPv4 下的169.254.0.0/16 |
| fd00::/8   | 通常意义上的内网地址段了，等价于 IPv4 的10.0.0.0/8, 172.16.0.0/12以及192.168.0.0/16这三个段 |
| fc00::/8   | 一个保留的巨大内网地址段，具体怎么用现在还没有规范           |

注意
区分公网与否最简单的方式，看是不是f开头和::开头，不是就是公网





Scope：后可理解为自己的连接范围
关于IP地址的scopt的描述，举个例子来说，比如说127.0.0.1这个地址属于local地址，它的scope就是host；比如说一个物理网卡分配了IP是192.168.56.101，这个地址就属于global的。

再简单一点，只看它后面参数：

| Scope  | 描述                     |
| ------ | ------------------------ |
| global | 全局合法                 |
| site   | 只在这个站点合法 (IPv6)  |
| link   | 只在这个设备合法         |
| host   | 只在这个host（机器）合法 |
|        |                          |


最常见的两种类型，一种是Scope:Global，另一种为Scope:Link。
1.Scope:Global:即你拥有的全局合法的ipv6地址。
2.Scope:Link:即你拥有了这个设备合法的ipv6地址。很多同学还没配置前，就在网络配置里看见了自己的ipv6地址，兴奋的不行，但是就是不能ping通ipv6网站。为啥，你的ipv6地址只有你自己的设备认识，你怎么ping通ipv6网站。

原文链接：https://blog.csdn.net/weixin_43976737/article/details/126769588



##### 4.6.4.2 一个简单的基于IPv6的server

```
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define BACKLOG 16

#define LISTEN_PORT 12345

void sigINT(int signo);

int main()
{
    int listen_fd = -1;

    if (signal(SIGINT, sigINT) == SIG_ERR)
    {
        printf("set signal handler(SIGINT) error!!!\n");
        exit(1);
    }

    // socket
    if ((listen_fd = socket(AF_INET6, SOCK_STREAM, 0)) < 0)
    {
        printf("create socket error=%d(%s)!!!\n", errno, strerror(errno));
        exit(1);
    }

    // bind
    struct sockaddr_in6 server_addr;
    server_addr.sin6_family = AF_INET6;              // IPv6
    server_addr.sin6_port   = htons(LISTEN_PORT);    // Port
    server_addr.sin6_addr   = in6addr_any;           // IP
    //inet_pton(AF_INET6, "2409:8762:efd:31:28a7:bdc4:fff9:da62", &server_addr.sin6_addr);    // 设置 IPv6 地址
    if (bind(listen_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        printf("socket bind error=%d(%s)!!!\n", errno, strerror(errno));
        exit(1);
    }

    // listen
    if (listen(listen_fd, BACKLOG) < 0)
    {
        printf("socket listen error=%d(%s)!!!\n", errno, strerror(errno));
        exit(1);
    }

    printf("server init ok, start to accept new connect...\n");

    while (1)
    {
        // accept
        int client_fd = accept(listen_fd, NULL, NULL);
        if (client_fd < 0)
        {
            printf("socket accept error=%d(%s)!!!\n", errno, strerror(errno));
            exit(1);
        }
        printf("accept one new connect(%d)!!!\n", client_fd);

        static const char *msg = "Hello, Client!\n";
        if (write(client_fd, msg, strlen(msg)) != strlen(msg))
        {
            printf("send msg to client error!!!\n");
        }
        close(client_fd);
    }
}

void sigINT(int signo)
{
    printf("catch SIGINT, quit...\n");
    close(listen_fd);
    exit(0);
}

```



需要注意的是，在ipv4中，地址通配符可以直接使用0来赋值，即
`servaddr.sin_addr.s_addr = 0`
而在ipv6的编程中不能用0直接赋值，原因是ipv6的地址是存放在一个长度为16的unit8_t数组中的。



##### 4.6.4.3 一个简单的基于IPv6的客户端

```
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <netdb.h>

#define LISTEN_PORT "12345"

#define MAXLINE 1024

void mygetaddinfo(struct sockaddr_in6 *servaddr, char *addr)
{
    struct addrinfo *ai, *hints;
    memset(hints, 0, sizeof(struct addrinfo));
    //只要ipv6地址族的结果
    hints->ai_family = AF_INET6;
    if ((getaddrinfo(addr, LISTEN_PORT, hints, &ai)) != 0)
    {
        perror("IN GETADDRINFO()");
        exit(1);
    }

    *servaddr = *(struct sockaddr_in6 *)ai->ai_addr;

    //指定使用的接口
    servaddr->sin6_scope_id = 6;
}

int main(int argc, char **argv)
{
    int                 sockfd, n;
    struct sockaddr_in6 servaddr;
    char                recvline[MAXLINE];
    socklen_t           len;
    if (argc != 2)
    {
        printf("INPUT ADDRESS!");
        exit(1);
    }

    if ((sockfd = socket(AF_INET6, SOCK_STREAM, 0)) < 0)
    {
        perror("SOCKET");
        exit(1);
    }
    bzero(&servaddr, sizeof(servaddr));
    mygetaddinfo(&servaddr, argv[1]);

    // if (inet_pton(AF_INET6, "::1", &servaddr.sin6_addr) <= 0)
    // {
    //     printf("inet_pton error!!!\n");
    //     exit(1);
    // }

    len = sizeof(servaddr);
    if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
    {
        perror("CONNEXT");
        exit(1);
    }

    n           = read(sockfd, recvline, MAXLINE);
    recvline[n] = 0;
    printf("%s\n", recvline);
    exit(0);
}

```



在客户端的代码中，使用了`getaddrinfo(char *, char *, struct addrinfo *, struct addrinfo **)`来获取服务端的sockaddr_in6结构体（如果已有地址串及已确定的端口，这调用并没有必要）。值得注意的是，如果使用的链路本地地址(Link-Local Address，以fe80:打头)，则必须指定sockaddr_in6中的sin6_scope_id成员，其成员的值可以通过`ip link`命令获得，为对应接口前的数字：

```
# ip link
5: sit0@NONE: <NOARP> mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/sit 0.0.0.0 brd 0.0.0.0
6: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 00:15:5d:ae:fd:ad brd ff:ff:ff:ff:ff:ff
```

如果使用的ipv6的环回地址`::1`也可以不用指定sin6_scope_id成员。



#### 4.6.5 TCP 头部格式

![tcp53156507f1fe0fc5.png](https://z4a.net/images/2024/02/22/tcp53156507f1fe0fc5.png)



在电脑上的wireshark抓包结果：

![1.gif](https://z4a.net/images/2024/02/22/1.gif)





**tcp_slowtmr** 函数中完成**重传**和**超时**处理，当重传达到设定次数，或者超时达到设定时间，则调用错误类型为 ERR_ABRT 的错误处理回调函数。

重传和超时事件有：

- PCB 控制块处于 SYN_SENT 状态，重传次数达到 TCP_SYNMAXRTX 次（默认 6 次）
- PCB 控制块处于其它状态，重传次数达到 TCP_MAXRTX 次（默认 12 次）
- 坚持定时器探查窗口达到 TCP_MAXRTX 次（默认 12 次）
- PCB 控制块处于 FIN_WAIT_2 状态，超时达到 TCP_FIN_WAIT_TIMEOUT 秒（默认 20 秒）
- PCB 控制块处于 SYN_RCVD 状态，超时达到 TCP_SYN_RCVD_TIMEOUT 秒（默认 20 秒）
- PCB 控制块处于 LAST_ACK 状态，超时达到 2 * TCP_MSL 秒（默认 120 秒）
- 使能保活、PCB 控制块处于 ESTABLISHED 或 CLOSE_WAIT 状态，超时达到 pcb->keep_idle + TCP_KEEP_DUR(pcb) 秒（默认 2 小时 10 分 48 秒）



lwip TCP 初始序列号：

在 lwIP 中，协议栈为每个新的 TCP 连接生成一个 TCP 初始序列号，tcp.c 中的函数 `tcp_next_iss` 用于这个目的。

```
/**
 * Calculates a new initial sequence number for new connections.
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(struct tcp_pcb *pcb)
{
#ifdef LWIP_HOOK_TCP_ISN
  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
#else /* LWIP_HOOK_TCP_ISN */
  static u32_t iss = 6510;

  LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
  LWIP_UNUSED_ARG(pcb);

  iss += tcp_ticks;       /* XXX */
  return iss;
#endif /* LWIP_HOOK_TCP_ISN */
}

```

这个算法很简单，一个固定值（6510）加上系统启动到当前的时间。这是一个常见的在 TCP 协议中为新连接生成初始序列号的方法。但是这个算法产生的值是可以预测的，以至于 lwIP 的 TCP 连接可能成为 TCP 欺骗攻击的目标。

> 对初始序列号的准确预测是 IP 欺骗、数据注入和会话劫持能成功的先决条件。举一个TCP Reset 攻击例子：
>
> 如果能准确预测初始序列号，就可以假冒客户端向服务器发送 RST 包，要求复位连接。由于 RST 包并不需要向应用层提交，服务器端的 TCP 协议栈只要接到该包就立即终止此次 TCP 连接，这将让真正的客户端连不上服务器，导致了拒绝服务攻击。
>
> 根据研究结果表明，Windows 2000、Windows XP SP1 的初始序列号都是可以预测的，从 Windows XP SP2 开始，初始序列号才能难以预测。
>



参考：

[[ 网络协议篇 ]TCP三次握手和四次挥手详解](https://blog.csdn.net/qq_51577576/article/details/121426400)

[嵌入式TCP/IP](https://blog.csdn.net/zhzht19861011/category_758863.html) 



#### 4.6.3 lwip多网卡支持协议栈改动

"lwip/ip4.h" 文件

```c
extern struct netif *lwip_ip4_route_src(const ip4_addr_t *src, const ip4_addr_t *dest);
#define LWIP_HOOK_IP4_ROUTE_SRC(src, dest) lwip_ip4_route_src(src, dest)
```

```
#include "lwip/ip4.h"
struct netif *lwip_ip4_route_src(const ip4_addr_t *src, const ip4_addr_t *dest)
{
    struct netif *netif;
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("addr 0x%x 0x%x\r\n", dest->addr, src->addr));

    /* iterate through netifs */
    NETIF_FOREACH(netif)
    {
        /* is the netif up, does it have a link and a valid address? */
        if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif)))
        {
            if (src != NULL)
            {
                LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("iter netif %s\r\n", netif->name));
                /* network mask matches? */
                if (ip4_addr_cmp(src, netif_ip4_addr(netif)))
                {
                    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("found ip4 route src %s\r\n", netif->name));
                    /* return netif on which to forward IP packet */
                    return netif;
                }
            }
        }
    }

    netif = netif_default;
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("use ip4 route src %s\r\n", netif->name));

    return netif;
}

```



### 4.7 socket



#### 4.7.1  socket 

4.7.1  地址

socket编程中，经常见到这两个结构体来处理网络地址：struct sockaddr 和 struct sockaddr_in 。

对于 sockaddr，引用  \#include <sys/socket.h>  头文件就可以，其结构体：

```c
struct sockaddr {
  uint8_t     sa_len;
  sa_family_t sa_family;
  char sa_data[14];
};
```

对于 sockaddr_in, 引用\#include<netinet/in.h> 可以找到，其结构体

```c
struct sockaddr_in {
 u8_t           sin_len;
 sa_family_t    sin_family;
 in_port_t      sin_port;
 struct in_addr sin_addr;
 #define SIN_ZERO_LEN 8
 char       sin_zero[SIN_ZERO_LEN];
};
```

这个结构体中还有一个 struct in_addr的结构体。其定义如下：

```c
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;

struct in_addr {
  in_addr_t s_addr;
};
```

在socket编程中，sin_port 和 sin_addr 都必须是网络字节序。因此需要用 htons 转化实际的端口值。

在lwip中，这两个都定义在sockets.h 文件中。

可以看到两个结构体的大小是一致的，都是16字节。因此可以互相转化，指向sockaddr_in结构的指针也可以指向sockaddr。

sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。白话一点就是，这个sockaddr描述的地址是给程序或者说CPU理解的。

sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。sockaddr_in是给写程序的人理解的。

一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于[socket](https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020)定义和赋值；sockaddr用于函数参数。例如：

```
struct sockaddr_in sock_addr;
struct sockaddr_in client_addr;

sock_addr.sin_family = AF_INET;
sock_addr.sin_port = htons(402);
sock_addr.sin_addr.s_addr = inet_addr(ip_addr);

...

bind(sockfd, (struct sockaddr *)&sock_addr, sizeof(sock_addr);

...
length = sizeof(struct sockaddr_in);
accept(sockfd, (struct sockaddr *)&client_addr, &length);

```



#### 4.7.2 select

API 原型

```c
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int select(int maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout);
```

参数说明：

maxfdp：集合中所有文件描述符的范围，为所有文件描述符的最大值加1

readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合

timeout: select的超时时间，它可以使select处于三种状态

- 若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；
- 若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数， 不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；
- timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回。

timeval结构体定义：

```c
struct timeval
{      
    long tv_sec;   /*秒 */
    long tv_usec;  /*微秒 */   
};
```

返回值：

0 --- 超时

-1 --- 失败

\>0 --- 标识就绪描述符的数目

使用select函数时，常用的几个宏

```c
#include <sys/select.h>   
FD_ZERO(fd_set*);       //清空fd_set集合，即让fd_set集合不再包含任何文件句柄。
FD_CLR(int ,fd_set*)    //清除某个位时可以使用
FD_SET(int ,fd_set *);   //将一个给定的文件描述符从集合中删除
FD_ISSET(int ,fd_set*);  //检测fd在fdset集合中的状态是否变化，当检测到fd状态发生变化时返回真,否则返回假。判断集合中指定的文件描述符是否可以读写
```

fd_set:  每一个bit对应一个文件描述符

使用select函数的过程一般是：

1. 先调用宏FD_ZERO将指定的fd_set清零
2. 然后调用宏FD_SET将需要测试的fd加入fd_set
3. 接着调用函数select测试fd_set中的所有fd
4. 最后用宏FD_ISSET检查某个fd在函数select调用后，相应位是否仍然为1



linux 上禁用/开启网卡的方法：

```
ifconfig eth0 down

ifconfig eth0 up
```



linux 上没有socket没有建立连接时进行select，writeset被置位的原因可能是这里：

内核版本 4.4

kernel\net\socket.c

```

SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
{
	int retval;
	struct socket *sock;
	int flags;

	/* Check the SOCK_* constants for consistency.  */
	BUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);
	BUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);
	BUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);
	BUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);

	flags = type & ~SOCK_TYPE_MASK;
	if (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
		return -EINVAL;
	type &= SOCK_TYPE_MASK;

	if (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))
		flags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;

	retval = sock_create(family, type, protocol, &sock);
	if (retval < 0)
		goto out;

	retval = sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));
	if (retval < 0)
		goto out_release;

out:
	/* It may be already another descriptor 8) Not kernel problem. */
	return retval;

out_release:
	sock_release(sock);
	return retval;
}

```



```

static int sock_map_fd(struct socket *sock, int flags)
{
	struct file *newfile;
	int fd = get_unused_fd_flags(flags);
	if (unlikely(fd < 0))
		return fd;

	newfile = sock_alloc_file(sock, flags, NULL);
	if (likely(!IS_ERR(newfile))) {
		fd_install(fd, newfile);
		return fd;
	}

	put_unused_fd(fd);
	return PTR_ERR(newfile);
}
```

```

struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname)
{
	struct qstr name = { .name = "" };
	struct path path;
	struct file *file;

	if (dname) {
		name.name = dname;
		name.len = strlen(name.name);
	} else if (sock->sk) {
		name.name = sock->sk->sk_prot_creator->name;
		name.len = strlen(name.name);
	}
	path.dentry = d_alloc_pseudo(sock_mnt->mnt_sb, &name);
	if (unlikely(!path.dentry))
		return ERR_PTR(-ENOMEM);
	path.mnt = mntget(sock_mnt);

	d_instantiate(path.dentry, SOCK_INODE(sock));

	file = alloc_file(&path, FMODE_READ | FMODE_WRITE,
		  &socket_file_ops);
	if (IS_ERR(file)) {
		/* drop dentry, keep inode */
		ihold(d_inode(path.dentry));
		path_put(&path);
		return file;
	}

	sock->file = file;
	file->f_flags = O_RDWR | (flags & O_NONBLOCK);
	file->private_data = sock;
	return file;
}
EXPORT_SYMBOL(sock_alloc_file);
```



```
static const struct file_operations socket_file_ops = {
	.owner =	THIS_MODULE,
	.llseek =	no_llseek,
	.read_iter =	sock_read_iter,
	.write_iter =	sock_write_iter,
	.poll =		sock_poll,
	.unlocked_ioctl = sock_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl = compat_sock_ioctl,
#endif
	.mmap =		sock_mmap,
	.release =	sock_close,
	.fasync =	sock_fasync,
	.sendpage =	sock_sendpage,
	.splice_write = generic_splice_sendpage,
	.splice_read =	sock_splice_read,
};
```

```

/* No kernel lock held - perfect */
static unsigned int sock_poll(struct file *file, poll_table *wait)
{
	unsigned int busy_flag = 0;
	struct socket *sock;

	/*
	 *      We can't return errors to poll, so it's either yes or no.
	 */
	sock = file->private_data;

	if (sk_can_busy_loop(sock->sk)) {
		/* this socket can poll_ll so tell the system call */
		busy_flag = POLL_BUSY_LOOP;

		/* once, only if requested by syscall */
		if (wait && (wait->_key & POLL_BUSY_LOOP))
			sk_busy_loop(sock->sk, 1);
	}

	return busy_flag | sock->ops->poll(file, sock, wait);
}
```



kernel\net\ipv4\af_inet.c

```
const struct proto_ops inet_stream_ops = {
	.family		   = PF_INET,
	.owner		   = THIS_MODULE,
	.release	   = inet_release,
	.bind		   = inet_bind,
	.connect	   = inet_stream_connect,
	.socketpair	   = sock_no_socketpair,
	.accept		   = inet_accept,
	.getname	   = inet_getname,
	.poll		   = tcp_poll,
	.ioctl		   = inet_ioctl,
	.listen		   = inet_listen,
	.shutdown	   = inet_shutdown,
	.setsockopt	   = sock_common_setsockopt,
	.getsockopt	   = sock_common_getsockopt,
	.sendmsg	   = inet_sendmsg,
	.recvmsg	   = inet_recvmsg,
	.mmap		   = sock_no_mmap,
	.sendpage	   = inet_sendpage,
	.splice_read	   = tcp_splice_read,
#ifdef CONFIG_COMPAT
	.compat_setsockopt = compat_sock_common_setsockopt,
	.compat_getsockopt = compat_sock_common_getsockopt,
	.compat_ioctl	   = inet_compat_ioctl,
#endif
};
EXPORT_SYMBOL(inet_stream_ops);
```



注意看，中间注释的一段文字中提到了

> 	 * NOTE. Check for TCP_CLOSE is added. The goal is to prevent
> 	 * blocking on fresh not-connected or disconnected socket. --ANK

```

/*
 *	Wait for a TCP event.
 *
 *	Note that we don't need to lock the socket, as the upper poll layers
 *	take care of normal races (between the test and the event) and we don't
 *	go look at any of the socket buffers directly.
 */
unsigned int tcp_poll(struct file *file, struct socket *sock, poll_table *wait)
{
	unsigned int mask;
	struct sock *sk = sock->sk;
	const struct tcp_sock *tp = tcp_sk(sk);
	int state;

	sock_rps_record_flow(sk);

	sock_poll_wait(file, sk_sleep(sk), wait);

	state = sk_state_load(sk);
	if (state == TCP_LISTEN)
		return inet_csk_listen_poll(sk);

	/* Socket is not locked. We are protected from async events
	 * by poll logic and correct handling of state changes
	 * made by other threads is impossible in any case.
	 */

	mask = 0;

	/*
	 * POLLHUP is certainly not done right. But poll() doesn't
	 * have a notion of HUP in just one direction, and for a
	 * socket the read side is more interesting.
	 *
	 * Some poll() documentation says that POLLHUP is incompatible
	 * with the POLLOUT/POLLWR flags, so somebody should check this
	 * all. But careful, it tends to be safer to return too many
	 * bits than too few, and you can easily break real applications
	 * if you don't tell them that something has hung up!
	 *
	 * Check-me.
	 *
	 * Check number 1. POLLHUP is _UNMASKABLE_ event (see UNIX98 and
	 * our fs/select.c). It means that after we received EOF,
	 * poll always returns immediately, making impossible poll() on write()
	 * in state CLOSE_WAIT. One solution is evident --- to set POLLHUP
	 * if and only if shutdown has been made in both directions.
	 * Actually, it is interesting to look how Solaris and DUX
	 * solve this dilemma. I would prefer, if POLLHUP were maskable,
	 * then we could set it on SND_SHUTDOWN. BTW examples given
	 * in Stevens' books assume exactly this behaviour, it explains
	 * why POLLHUP is incompatible with POLLOUT.	--ANK
	 *
	 * NOTE. Check for TCP_CLOSE is added. The goal is to prevent
	 * blocking on fresh not-connected or disconnected socket. --ANK
	 */
	if (sk->sk_shutdown == SHUTDOWN_MASK || state == TCP_CLOSE)
		mask |= POLLHUP;
	if (sk->sk_shutdown & RCV_SHUTDOWN)
		mask |= POLLIN | POLLRDNORM | POLLRDHUP;

	/* Connected or passive Fast Open socket? */
	if (state != TCP_SYN_SENT &&
	    (state != TCP_SYN_RECV || tp->fastopen_rsk)) {
		int target = sock_rcvlowat(sk, 0, INT_MAX);

		if (tp->urg_seq == tp->copied_seq &&
		    !sock_flag(sk, SOCK_URGINLINE) &&
		    tp->urg_data)
			target++;

		if (tp->rcv_nxt - tp->copied_seq >= target)
			mask |= POLLIN | POLLRDNORM;

		if (!(sk->sk_shutdown & SEND_SHUTDOWN)) {
			if (sk_stream_is_writeable(sk)) {
				mask |= POLLOUT | POLLWRNORM;
			} else {  /* send SIGIO later */
				sk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk);
				set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);

				/* Race breaker. If space is freed after
				 * wspace test but before the flags are set,
				 * IO signal will be lost. Memory barrier
				 * pairs with the input side.
				 */
				smp_mb__after_atomic();
				if (sk_stream_is_writeable(sk))
					mask |= POLLOUT | POLLWRNORM;
			}
		} else
			mask |= POLLOUT | POLLWRNORM;

		if (tp->urg_data & TCP_URG_VALID)
			mask |= POLLPRI;
	}
	/* This barrier is coupled with smp_wmb() in tcp_reset() */
	smp_rmb();
	if (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))
		mask |= POLLERR;

	return mask;
}
EXPORT_SYMBOL(tcp_poll);
```



#### 4.7.3 组播

1. 组播：实际情况下，经常需要对一组特定的主机进行通信，而不是所有局域网上的主机

- IP组播（也称多址广播或多播），是一种允许一台或多台主机发送数据包到多台主机的TCP/IP网路技术。
- 多播是 IPv6 数据包的 3 种基本目的地址类型之一，多播是一点对多点的通信,　IPv6 没有采用 IPv4 中的组播术语，而是将广播看成是多播的一个特殊例子。



组播地址

IP 组播通信必须依赖于 IP 多播地址，在 IPv4 中它是一个 D 类 IP 地址，范围从 224.0.0.0 到 239.255.255.255，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址3类：

- 局部链接多播地址范围在 224.0.0.0~224.0.0.255，这是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包；
- 预留多播地址为 224.0.1.0~238.255.255.255，可用于全球范围（如Internet）或网络协议；
- 管理权限多播地址为 239.0.0.0~239.255.255.255，可供组织内部使用，类似于私有 IP 地址，不能用于 Internet，可限制多播范围。





### 4.8 u-boot

#### 4.8.1 起源

  U-Boot 起源于 Magnus Damm 编写的名为 8xxROM 的针对于 8xx PowerPC 的引导加载程序。1999 年 10 月，Wolfgang Denk 将其在 SourceForge.net 开源，由于该网站不允许项目名称以数字开头，因此，更名为 PPCBoot（即 PowerPC Boot 的缩写）。2000 年 7 月 19 日首次公开发布 PPCBoot-0.4.1。

> 1. Wolfgang Denk 是 DENX Software Engineering GmbH（简称 DENX） 的创始人，PPCBoot 实际属于 DENX 公司
> 2. 因为 linus ➔ linux 所以 Denk ➔ DENX ？
> 3. DENX 是一家致力于使用自由软件的公司

随着 PPCBoot 被扩展到了 ARM 架构，DENX 认为，PPCBoot 这个名字已经不再合适，于是，在 PPCBoot−2.0.0 于 2002 年 10 月发布时决定将项目更名（SourceForge.net 新建项目）为 Das U-Boot（Universal Boot Loader 的缩写），其中的 Das 是一个德语定冠词，官方说是为了创建一个双关语（致敬经典的 1981 年德国潜艇电影 Das Boot）。

> 1. 代码仓库：https://source.denx.de/u-boot
> 2. Github 仓库：https://github.com/u-boot/u-boot

从 2008 年 10 月的版本开始，U-Boot 版本的名称从没有更深层次含义的数字版本号更改为基于时间戳的编号，通常格式 U-Boot vYYYY.MM.x，其中，YYYY 是年份（如 2022）；MM 是月份（如 08）；.x 可能没有，如果存在，这部分是 bug 修复版本（如 1）或者候选版本（如 rc1）。

U-Boot 的源码的结构基本也是向 Linux 看齐（其中部分代码就来自于 Linux kernel），只不过没有 Linux 代码那么复杂。如今，U-Boot 源码每天都有大量变更，最新的版本有 1 万 4 千多个文件，近 300 万行代码。源码中各文件的层级结构可以参考下图：
![uboot_code_archieve.png](https://z4a.net/images/2023/07/21/uboot_code_archieve.png)



#### 4.8.2 uboot 编译

可以通过uboot下的Makefile看到uboot的版本信息：

```
VERSION = 2017
PATCHLEVEL = 09
SUBLEVEL =
EXTRAVERSION =
NAME =
```

通用的编译参数如下：

```
make CROSS_COMPILE=${TOOLCHAIN_GCC}  all --jobs=${JOB} ${OUTOPT}
```

在编译参数添加 V=1 会打印出编译过程



U-Boot 本身的启动阶段划分为了多个不同的阶段：TPL ➜ VPL ➜ SPL ➜ U-Boot。在源码代码设计中，SPL 其实是一个框架，TPL 和 VPL 都属于 SPL 框架中的一部分。

TPL
  TPL（Tertiary Program Loader，第三段程序加载器） 用于早期的初始化，并且尽可能的小，它负责加载 VPL 或 SPL。根据官方文档，TPL 本身属于 SPL 的精简，代码就在 SPL 代码中，通过宏 CONFIG_TPL_BUILD 来区分，而且，现在只有 powerpc 的 mpc85xx 有这个要求并将实现它。

VPL
  VPL 是一个可选的安全启动验证过程。从裸机功能上来看，VPL 是一个独立的过程，负责校验 A/B 两个 SPL，并选择正确的来执行；在代码实现上，VPL 也是 SPL 中的一部分。目前，VPL 的细节还在设计实现中，现在它会直接跳转到 SPL。

SPL
  SPL（Secondary Program Loader，第二段程序加载器），这里的第二段程序其实就是指的 U-Boot，也就是，SPL 是第一段程序，优先执行，然后他再去加载 U-Boot。那么 U-Boot 本身已经是一个bootloader了，为啥要有 SPL 这个东西的存在呢？

  这个主要原因是对于一些 MCU 来说，它的内部 SRAM 可能会比较小，小到无法装载下一个完整的 U-Boot 镜像，那么就需要 SPL，它主要负责初始化外部 RAM 运行环境，并加载真正的 U-Boot 镜像到外部 RAM 中来执行。

U-Boot

U-Boot 阶段包含完整的 U-Boot 功能，例如，引导逻辑、各种 U-Boot 命令。



Image 镜像
  成功编译之后，就会在 U-Boot 源码的根目录下产生多个可执行二进制文件以及编译过程文件，这些文件都是 u-boot.xxx 的命名方式。这些文件由一些列名为 .xxx.cmd 的文件生成，.xxx.cmd 这些文件都是由编译系统产生的用于处理最终的可执行程序的。注意，下面部分文件可能没有与自己的 make menuconfig 中的配置有关系。
u-boot： 这个文件是编译后产生的 ELF 格式的最原始的 U-Boot 镜像文件，后续的文件都是由它产生的！.u-boot.cmd 这个命令脚本描述了如何产生。

u-boot-nodtb.bin： 这文件是使用编译工具链的 objcopy 工具从 u-boot 这个文件中提取来的，它只包含可执行的二进制代码。就是把 u-boot 这个文件中对于执行不需要的节区删除后剩余的仅执行需要的部分。由 .u-boot-nodtb.bin.cmd 这个命令脚本产生。
u-boot-dtb.bin： 在 u-boot-nodtb.bin 尾部拼接上设备树后形成的文件。由 .u-boot-dtb.bin.cmd 这个命令脚本产生。

u-boot.bin： 就是把 u-boot-dtb.bin 重命名得到的。由 .u-boot.bin.cmd 这个命令脚本产生。

u-boot.img： 在 u-boot.bin 开头拼接一些信息后形成的文件。由 .u-boot.img.cmd 这个命令脚本产生。
u-boot-dtb.img： 在 u-boot.bin 开头拼接一些信息后形成的文件。由 .u-boot-dtb.img.cmd 这个命令脚本产生。
u-boot.srec： S-Record 格式的镜像文件。由 .u-boot.srec.cmd 这个命令脚本产生。
u-boot.sym： 这个是从 u-boot 中导出的符号表文件。由 .u-boot.sym.cmd 这个命令脚本产生。
u-boot.lds： 编译使用的链接脚本文件。由 .u-boot.lds.cmd 这个命令脚本产生。
u-boot.map： 编译的内存映射文件。该文件是有编译工具链的连接器输出的！
System.map： 记录 U-Boot 中各个符号在内核中位置，但是这个文件是使用了 nm 和 grep工具来手动生成的

u-boot.dtb： 这个是编译好的设备树二进制文件。就是 ./dts/dt.dtb 重命名得到的。

编译之后，源码的根目录下会生成一堆二进制的文件（.bin），其中，在默认的 U-Boot 配置下，我们实际需要的 U-Boot 实际包含两部分：spl/u-boot-spl.bin 和 u-boot.bin。


U-Boot的启动从时间先后来划分，可以分为两级启动阶段。
1. 第一级（relocate之前）：使用的是U-Boot自己的dtb。
一般第一阶段只需要加载emmc、nand、cru、grf、uart等模块，为了加快设备树的解析过程，dts里一般只
去使能会用到的节点。需要特别注意：第一阶段要使能的节点除了指明 "status=okay" 之外，还必须增加"uboot,dm-pre-reloc;"属性，否则解析设备树时该节点会被忽略。这部分一般都在平台相关的[chip]-uboot.dtsi里定义，例如：
./arch/arm/dts/px30-u-boot.dtsi
./arch/arm/dts/rk3399-u-boot.dtsi
./arch/arm/dts/rk3128-u-boot.dtsi
......

./arch/arm/dts/px30-u-boot.dtsi如下：
......
&nandc0 {
u-boot,dm-pre-reloc;
};
&emmc {
u-boot,dm-pre-reloc;
};
&cru {
u-boot,dm-pre-reloc;
};
......

2. 第二级启动（relocate之后）：使用的是kernel的dtb。
一旦进入第二级阶段后，启动流程里会迅速切到kernel的dtb(取决于CONFIG_USING_KERNEL_DTB是否使
能），后续更多的驱动初始化都是使用kernel的dtb信息。


4.8.3 情景分析



uboot中非常重要的全局变量 DECLARE_GLOBAL_DATA_PTR;

> ```
> #define DECLARE_GLOBAL_DATA_PTR register volatile gd_t *gd asm ("r8")
> ```
>
> 解析：
> (1)gd是一个gd_t类型的全局变量，用宏的方式来声明这个变量是方便使用，在要使用gd变量的文件里添加这个宏即可。
> (2)register：希望gd变量尽可能放在寄存器里；
> (3)volatile：指明这个变量是易变的，每次使用gd变量时都去地址处读取，不要使用缓存的gd变量的值；
> (4)gd_t：gd变量时gd_t类型；定义在 u-boot/include/asm-generic/global_data.h
> (5)asm (“r8”)：用r8寄存器来存放gd变量
> 备注：这个宏只是定义了gd指针变量，还没有给该指针赋值；







### 4.9 Linux 开发



Buildroot是Linux平台上一个开源的嵌入式Linux系统自动构建框架。整个Buildroot是由Makefile脚本和Kconfig配置文件构成的。你可以通过Buildroot配置，编译出一个完整的可以直接烧写到机器上运行的Linux系统软件。

Buildroot有以下几点优势：
1. 通过源码构建，有很大的灵活性；
2. 方便的交叉编译环境，可以进行快速构建；
3. 各系统组件配置方便，方便定制开发。



vmlinux：vm 是 Virtual Memory 的缩写，它是由用户对内核源码编译出来的最原始的内核文件，是一个 ELF（ Executable and Linkable Format）格式的文件。当我们编译完 Kernel 后，在源码根目录下就会生成该文件。vmlinux 是最原始的镜像文件，其他镜像文件都有它来生成。所有其他未压缩的镜像都直接或者间接由它生成。当虚拟内存被开发为更容易的多任务处理能力时，“vm”被放在文件的前面，以表明内核支持虚拟内存。有一段时间，Linux 内核被称为 vmlinux。

注意，在 `./arch/arm/boot/compressed` 下，还有个经过压缩之后的 vmlinux 。所有其他与压缩有关的镜像都直接或者间接由它生成。

vmlinuz：随着内核变得越来越大，无法容纳到可用的引导内存中，因此压缩了内核镜像，命名上则将最后 x 改为 z，以表示它是用 zlib 压缩压缩的。这种压缩并不总是被使用，而是经常被 LZMA 或 BZIP2 取代。

Image：它是基于根目录下**未压缩的 vmlinux** 生成的，编译完 Kernel 后，在对应架构的 boot（例如，arch\arm\boot） 目下就会生成该文件。它经过 objcopy 处理的只包含二进制数据的内核代码，就是将 vmlinux 中的 ELF 头和尾部的符号表等去掉之后剩余的内容。

zImage：它是基于**压缩过的 vmlinux** 生成的，编译完 Kernel 后，在对应架构的 boot（例如，arch\arm\boot） 目下就会生成该文件。

bzImage：bz 表示 big zImage，其格式与 zImage 类似，但采用了不同的压缩算法，bzImage 的压缩率更高。

uImage：这是 uboot 专用的镜像文件，它是在 zImage 之前加上一个长度为 0x40 的头信息(tag)，在头信息内说明了该镜像文件的类型、加载位置、生成时间、大小等信息。换句话说，若直接从 uImage 的 0x40 位置开始执行，则 zImage 和 uImage 没有任何区别。

#### 4.9.1 Devicetree

[Device Tree（一）：背景介绍 ](http://www.wowotech.net/device_model/why-dt.html)

[Device Tree（二）：基本概念](http://www.wowotech.net/device_model/dt_basic_concept.html)

[Device Tree（三）：代码分析](http://www.wowotech.net/device_model/dt-code-analysis.html)

[Device Tree（四）：文件结构解析](http://www.wowotech.net/device_model/dt-code-file-struct-parse.html)



Device tree 转化

```
dtc -I dtb rk3308b-roc-cc-amic_emmc.dtb -O dts -o rk3308_build_src.dts (-I 是大写字符 i)
```





### 4.10 MMU

MMU(Memory Management Unit)，即内存管理单元，是现代CPU架构中不可或缺的一部分，MMU主要包含以下几个功能：虚实地址翻译, 访问权限控制, 引申的物理内存管理

MMU是一种硬件电路，再直白一点，就是使用与或非门组合而成的数字电路，既然是电路，那么就有输入和输出，输入就是CPU发起的虚拟地址，输出就是最终转换后的物理地址。

  CPU根本不知道访问的地址是物理的还是虚拟的，它只访问一个地址，然后从数据线上获取数据。未开启MMU时，CPU的访问地址直接通过地址总线访问到外部内存，此时CPU的访问地址就是物理地址。启用MMU时，CPU的访问地址是虚拟地址，经过MMU转化为物理地址，从而访问外部内存里的数据。

  暂且把MMU看成一个黑盒，下图为一个使用虚拟地址寻址的系统框图，CPU发起访问虚拟地址0x00000000来访问内存，在0x00000000被送到内存之前，先经过了MMU做了虚拟地址到物理地址的转换，MMU输出为0xC0000000，然后通过并行总线访问了物理地址为0xC0000000的地址空间

​	**页表是一种数据结构**，再直白点，**基本在32位的ARM处理器中，页表是uint32类型的数组，且数组大小为4K**，页表存放在内存当中，页表里存放了虚拟地址与物理地址的对应关系，VA到PA的转换过程其实就是MMU查询和解析页表的过程



![image-20230921153155682](C:\Users\yunzhi\AppData\Roaming\Typora\typora-user-images\image-20230921153155682.png)

CPU+主存的框架。这基本上是现在复杂CPU的主流做法，CPU内部包含控制器、运算器、寄存器，使用虚拟地址，经过MMU可以转化成物理地址。其中MMU里面有一个页表高速缓存表（Table Lookup Buffer，简称TLB）和页表遍历单元（Table Walk Unit，简称TWU），当TLB中缓存着要访问的虚拟地址到物理地址的转换关系的时候，就可以直接找到的物理地址，通过该物理地址在L1 cache中查找数据。如果TLB中没有缓存要访问虚拟地址对应的物理地址，这时会通过TWU模块遍历主存中的页表，查找相应的物理地址，找到后再通过这个物理地址访问L1 cache。如果L1 cache中存在着要访问的物理地址对应的内容，直接返回给相应的寄存器。如果L1 cache中没找到相应的数据，就依次从L2、L3 cache中查找，如果在所有层级的cache中都没查找到有效的数据，就会直接访问主存，取出物理地址对应的数据，然后分别给到寄存器和L1 cache。

其中实线部分是命中TLB及cache的数据访问方式，虚线部分是没有命中TLB及cache，通过TWU和页表访问主存获取数据的方式。这个框架相对于冯·诺依曼体系结构多了MMU及cache，这两个单元主要是为了解决两个问题，一个是地址空间保护、内存使用效率低的问题，另一个是冯·诺依曼体系结构访问指令、数据共用存储器慢的问题。



### 4.11 MMC/SD/SDIO

MMC是MultiMediaCard的简称，从本质上看，它是一种用于固态非易失性存储的内存卡（memory card）规范[1]，定义了诸如卡的形态、尺寸、容量、电气信号、和主机之间的通信协议等方方面面的内容。

从1997年MMC规范发布至今，基于不同的考量（物理尺寸、电压范围、管脚数量、最大容量、数据位宽、clock频率、安全特性、是否支持SPI mode、是否支持DDR mode、等等），进化出了MMC、SD、microSD、SDIO、eMMC等不同的规范（如下面图片1所示）。虽然乱花迷人，其本质终究还是一样的，丝毫未变，这就是Linux kernel将它们统称为MMC的原因。



![](http://www.wowotech.net/content/uploadfile/201612/45b6e3aeed9e014036481cbdc767d96920161225135201.gif)



> MMC、SD、SDIO的技术本质是一样的（使用相同的总线规范，等等），都是从MMC规范演化而来；
>
> MMC强调的是多媒体存储（MM，MultiMedia）；
>
> SD强调的是安全和数据保护（S，Secure）；
>
> SDIO是从SD演化出来的，强调的是接口（IO，Input/Output），不再关注另一端的具体形态（可以是WIFI设备、Bluetooth设备、GPS等等）。



[MMC/SD/SDIO介绍]: http://www.wowotech.net/basic_tech/mmc_sd_sdio_intro.html

### 4.12 CAN 

一些名词



| can    | Controller Area Network          | 控制器局域网          |
| ------ | -------------------------------- | --------------------- |
| CAN_FD | CAN with flexible data-rate      | 带有灵活数据速率的CAN |
| IDE    | Identifier Extension             | 标识符扩展            |
| DLC    | Data Length Code                 | 数据长度码            |
| RTR    | Remote Transmission Request      | 远程传输请求          |
| SS     | Synchronization Segment          | 同步段                |
| TSEG1  | Time Segment before Sample Point | 采样点前的时间段      |
| TSEG2  | Time Segment after Sample Point  | 采样点后的时间段      |
| SJW    | Resynchronization Jump Width     | 重同步跳转宽度        |



CAN（Controller Area Network）协议的建议要求对时钟频率最大限度的最大限度地容忍1.58%。

接收过滤器组模式（一般是2个32位寄存器）

- 屏蔽位模式

一个32位的寄存器，这里称作 regID，内容为支持的can 帧头信息，包括 ID，rtr，IDE。

一个32位寄存器，这里称作 regMASK，作为掩码。用法是收到的can帧 ，这里称作 can_frame， regMASK 为1的那些位 对应的 regID 的值，必须于 can_frame 帧头相应的值一致才不会被过滤掉。



- 标识符列表模式

将第二个掩码寄存器也来做帧 ID 匹配。当收到的数据匹配这两个过滤器任何一个，就可以被过滤通过



对于fm20s400，根据手册的意思，AMR0-3 寄存器中"0"表示 ACR0-3 中相应位置的位必须与消息标识符匹配，"1"表示屏蔽，即不需

要与消息标识符匹配。 (这个掩码模式可能与一些cpu的用法有区别)

有下面两种模式

单个4字节过滤器。这种模式和上面屏蔽位模式一样

两个较短的过滤器。可以认为是两个屏蔽位模式，不过第二个屏蔽位模式屏蔽的ID只支持 ID28~ID18 和RTR。



【fyi】[stm32 CAN 通讯滤波 看了那么多 这个弄懂了_标准帧双滤波-CSDN博客](https://blog.csdn.net/Soonjn/article/details/103267906)



can 异常处理

