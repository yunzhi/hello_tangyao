# 我的常用开发技巧



## **一、编译篇**

### 1.1 **CMAKE 构建系统**

一个非常简单的入门

某工程目录如下

 ![cmake_demo.jpg](https://z4a.net/images/2023/05/24/cmake_demo.jpg)

说明：工程的源文件放到了src下，这些源文件会依赖cJSON, httpclient, mbedtls这几个文件夹的一些文件, 工程中用到的头文件放到了inc下.

根目录的CMakeLists.txt 简单实现功能的写法

```cmake
# CMake最低版本号要求
cmake_minimum_required(VERSION 3.1)

# 项目信息
# required, should be soon after cmake_minimum_required().
project(onenet4OTA) # 写入工程名

set (CMAKE_C_COMPILER "/usr/bin/gcc")
set (CMAKE_CXX_COMPILER "/usr/bin/g++")
set (CMAKE_C_FLAGS "-g -Wall")

# 如果需要进行调试需要设置这个命令
set(CMAKE_BUILD_TYPE Debug)

# 向工程添加多个特定的头文件搜索路径，路径之间用空格分隔
# 相当于指定g++编译器的-I参数
include_directories (${CMAKE_SOURCE_DIR})
include_directories (${CMAKE_SOURCE_DIR}/inc)
include_directories (${CMAKE_SOURCE_DIR}/httpclient/include)
include_directories (${CMAKE_SOURCE_DIR}/cJSON)

# 把src目录下的源文件存列表存放到变量SOURCES里
file(GLOB SOURCES src/*.c)

# 指定生成目标
add_executable(${PROJECT_NAME} ${SOURCES})

add_subdirectory(mbedtls)
add_subdirectory(httpclient)
add_subdirectory(cJSON)

target_link_libraries(${CMAKE_PROJECT_NAME} mbedlts httpclient cJSON)

# 设置生成目标后exe文件存放位置
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
```

子/组件目录的写法：

```cmake
file(GLOB SRC *.c) #包含该目录的所有.c的文件列表
include_directories(.) #当前路径为头文件搜索路径
# 生成该组件的静态库
add_library(cJSON STATIC 
    ${SRC}
    )
```

看看其他几个文件夹的CmakeLists.txt

```cmake
file(GLOB SRC src/*.c)
include_directories(include)
add_library(httpclient STATIC
    ${SRC}
    oneos/http_oneos_wrapper.c
    )
```

如何编译这个项目？

在根目录创建一个 build（可以根据个人喜好命名）文件夹，cd 进去 

```shell
mkdir build
cd build
cmake ../

cmake --build .
```

 ![cmake_build.gif](https://z4a.net/images/2023/05/24/cmake_build.gif)


> 备注：cmake自带的常用变量
>
> PROJECT_SOURCE_DIR：工程的根目录
>
> PROJECT_BINARY_DIR：运行cmake命令的目录，通常为${PROJECT_SOURCE_DIR}/build
>
> PROJECT_NAME：返回通过 project 命令定义的项目名称
>
> CMAKE_CURRENT_SOURCE_DIR：当前处理的 CMakeLists.txt 所在的路径
>
> CMAKE_CURRENT_BINARY_DIR: target 编译目录
>
> CMAKE_CURRENT_LIST_DIR: CMakeLists.txt 的完整路径
>
> EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置
>
> LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置


参考：

生成多个可执行文件将add_executable 修改如下

```cmake
file( GLOB_RECURSE mains RELATIVE "${CMAKE_CURRENT_SOURCE_DIR}"
    "${CMAKE_CURRENT_SOURCE_DIR}/test_server.c"
    "${CMAKE_CURRENT_SOURCE_DIR}/test_client.c"
)

#遍历生成可执行文件
foreach(mainfile IN LISTS mains)
    get_filename_component(mainfile ${mainfile} NAME_WE)
    add_executable(${mainfile} ${mainfile})
endforeach()
```

### 1.2 Scons

一些通用的技巧：

Sconstruct 脚本里

Decider函数可以设定编译根据什么理由进行更新 . 例如：Decider('content') 或者 Decider("timestamp-newer")

Library 函数可以来生成库， 例如： Library('foo', ['f1.c', 'f2.c', 'f3.c'])



在scons 中通过 scons --verbose 可以看到具体编译每一个文件执行了什么操作，例如最终生成oneos.elf 的指令如下：

> arm-none-eabi-gcc -o oneos.elf -mcpu=cortex-m3 -mthumb -ffunction-sections -fdata-sections -Wl,--gc-sections,-Map=oneos.map,-cref,-u,Reset_Handler -T board/linker_scripts/link.lds -L F:\code\gitlab\oneos/drivers/link/ build\bsp\application\main.o build\bsp\application\testlib\testlib.o build\bsp\board\board.o build\bsp\board\CubeMX_Config\Src\bsp.o build\bsp\board\CubeMX_Config\Src\stm32f1xx_it_bsp.o build\bsp\board\CubeMX_Config\Src\stm32f1xx_hal_msp.o build\bsp\board\CubeMX_Config\Src\system_stm32f1xx.o board\startup\startup_stm32f103xe_gcc.o build\arch\arm\armv7m\gcc\arch_exception_gcc.o build\arch\arm\armv7m\gcc\arch_task_switch_gcc.o build\arch\arm\armv7m\arch_task.o build\arch\arm\armv7m\arch_exception.o build\arch\arm\armv7m\arch_interrupt.o build\arch\arm\armv7m\arch_misc.o build\arch\arm\armv7m\arch_atomic.o build\kernel\source\os_block.o build\kernel\source\os_clock.o build\kernel\source\os_event.o build\kernel\source\os_idle.o build\kernel\source\os_kernel_lock.o build\kernel\source\os_kernel_log.o build\kernel\source\os_mb.o build\kernel\source\os_mem_firstfit.o build\kernel\source\os_mem_pool.o build\kernel\source\os_memory.o build\kernel\source\os_mq.o build\kernel\source\os_mutex.o build\kernel\source\os_sched.o build\kernel\source\os_sem.o build\kernel\source\os_spinlock.o build\kernel\source\os_startup.o build\kernel\source\os_task.o build\kernel\source\os_timer.o build\kernel\source\os_util.o build\kernel\source\os_version.o build\kernel\source\os_workqueue.o build\drivers\graphic\graphic.o build\drivers\graphic\atk_tflcd9341.o build\drivers\graphic\font\font_asc2_1608.o build\drivers\graphic\font\font_asc2_2412.o build\drivers\graphic\font\font_asc2_3216.o build\drivers\hal\st\devices\stm32_devices.o build\drivers\hal\st\drivers\drv_gpio.o build\drivers\hal\st\drivers\drv_usart.o build\drivers\hal\st\drivers\drv_hwtimer.o build\drivers\hal\st\drivers\drv_pwm.o build\drivers\hal\st\drivers\drv_pulse_encoder.o build\drivers\hal\st\drivers\drv_spi.o build\drivers\hal\st\drivers\drv_adc.o build\drivers\hal\st\drivers\drv_dac.o build\drivers\hal\st\drivers\drv_can.o build\drivers\hal\st\drivers\drv_rtc.o build\drivers\hal\st\drivers\flash\drv_flash_f1.o build\drivers\hal\st\drivers\drv_iwdg.o build\drivers\hal\st\drivers\drv_sram.o build\drivers\hal\st\drivers\drv_common.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_dma.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_cortex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_crc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_pwr.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_cec.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_exti.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_usart.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_spi.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_spi.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_can.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_dac.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_dac_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc_ex.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_iwdg.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_ll_fsmc.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_sram.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash.o build\drivers\hal\st\STM32F1xx_HAL\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash_ex.o build\drivers\infrared\infrared.o build\drivers\infrared\remote_control_atk.o build\drivers\sensors\sensor.o build\drivers\sensors\photo_diode.o build\components\dlog\source\dlog.o build\components\dlog\source\backend\console_backend.o build\components\dlog\source\syslog\syslog.o build\components\shell\source\shell_buildin_cmd.o build\components\shell\source\shell_main.o build\components\shell\source\shell_process.o build\components\shell\source\shell_symbol.o build\libc\source\common\gmtime_r.o build\libc\source\newlib\chdir.o build\libc\source\newlib\dirent.o build\libc\source\newlib\fcntl.o build\libc\source\newlib\fsync.o build\libc\source\newlib\getcwd.o build\libc\source\newlib\ioctl.o build\libc\source\newlib\libc.o build\libc\source\newlib\mkdir.o build\libc\source\newlib\rmdir.o build\libc\source\newlib\statfs.o build\libc\source\newlib\stdio.o build\libc\source\newlib\syscalls.o build\libc\source\newlib\time.o build\common\source\option_parse.o build\common\source\ring_blk_buff.o build\common\source\ring_buff.o build\drivers\misc\adc.o build\drivers\block\block_device.o build\drivers\bus\bus.o build\drivers\can\can.o build\drivers\timer\clockevent.o build\drivers\timer\clocksource.o build\drivers\timer\clocksource_cortexm.o build\drivers\console\console.o build\drivers\misc\dac.o build\drivers\device.o build\drivers\dma\dma_ram.o build\drivers\driver.o build\drivers\eeprom\eeprom.o build\drivers\eeprom\eeprom_info.o build\drivers\fal\fal.o build\drivers\fal\fal_block.o build\drivers\fal\fal_mtd.o build\drivers\fal\fal_part.o build\drivers\timer\hrtimer.o build\drivers\i2c\i2c.o build\drivers\mtd\mtd.o build\drivers\pin\pin.o build\drivers\misc\pulse_encoder.o build\drivers\misc\push_button.o build\drivers\misc\pwm.o build\drivers\rtc\rtc.o build\drivers\serial\serial.o build\drivers\sflash\sfbus.o build\drivers\sflash\sfdp.o build\drivers\sflash\sfdp_basic.o build\drivers\sflash\sflash.o build\drivers\sflash\sflash_info.o build\drivers\dma\soft_dma.o build\drivers\i2c\soft_i2c_bus.o build\drivers\i2c\soft_i2c_bus_config.o build\drivers\spi\spi_core.o build\drivers\spi\spi_dev.o build\drivers\timer\timer.o build\drivers\boot\cotex-m\vector_table.o build\drivers\watchdog\watchdog.o -lc -lm



我们烧录到stm32芯片内部的bin文件是通过对oneos.elf进行如下的转换生成的

arm-none-eabi-objcopy -R .reserved_ram -O binary oneos.elf oneos.bin

> 注： arm-none-eabi-objcopy -R参数： Remove section <name> from the output
>
> objcopy -O binary 时会删掉一些编译器产生的中间段.
>
> oneos 之所以删掉 reserved_ram 这个自定义的段，是因为这个段里存储的数据不用保存到ROM中。同时因为链接文件头RAM0定义的地址和ROM的地址不连续，如果不删除，在做objcopy时，会自动填充不连续部分，导致bin文件体积变得巨大。


> 在 osconfig.py 的 CFLAGS 或者 LFLAGS 加上 --verbose 也可以看到gcc的编译或者链接过程

scons的一些操作

> scons --debug=explain 为啥要编译这个文件
>
> scons --tree=all 打印编译文件的所有依赖信息
>
> scons --tree=all build\drivers\watchdog\watchdog.o 后面的文件为编译文件位于build目录的相对路径
>
> scons --debug=presub 打印具体执行了什么操作来编译的

 ![scons_debug.gif](https://z4a.net/images/2023/05/24/scons_debug.gif)



scons 把文件打包成库再链接只需要在sconscript 的  AddCodeGroup 语句加上 LIBRARY=[] 就可以

```
AddCodeGroup('test_app', src = src, depend = [''], LIBRARY = [], LINKFLAGS=linkflags)
```

在oneos上，包含init_call 的函数文件在编译成库再链接后，因为 init_call 这个段没有实际被调用导致被优化，因此如果需要将库中的符号全部链接到目标文件，可以在编译参数中添加  -Wl,--whole-archive 和 -Wl,-no-whole-archive。如下是一个示例。

```python
import os
import osconfig
from build_tools import *

pwd = PresentDir()

src  = Glob('*.c')
path =  [pwd]
group = []

libname = 'test_app'

link_libname = pwd + '/lib' + libname + '.a'
linkflags = ' -Wl,--whole-archive ' + link_libname + ' -Wl,-no-whole-archive'

#将*.c的代码编译成库
# group += AddCodeGroup(libname, src = src, depend = [''], LIBRARY = []) 

#将链接参数添加到目标文件的链接参数中
group += AddCodeGroup(libname, src = '', depend = [''], LINKFLAGS=linkflags) 

Return('group')
```



1.1章中所提到的工程用scons的脚本如下：

根目录脚本：

```python
import os

cwd = os.getcwd()

env = Environment()

# 工程名
env["project_name"] = "sconsTest"

inc_path = [
    cwd,
    cwd + '/inc',
    cwd + '/httpclient/include',
    cwd + '/cJSON',
    cwd + '/mbedtls']
# inc_path = [cwd + '/inc']

#
env.Append(CCFLAGS = ['-g'])
env.Append(CPPPATH = [inc_path])

# 生成文件位置
env['build_bin_root'] = ['#/build/bin/']

#Export 和子目录的Import对应，是为了传递env变量
Export('env')

objs = []

VariantDir('build', 'src')

# #src目录的文件包含程序入口执行的main函数, 需要编成object, 并且放到obj最开始，就不用考虑库循环链接的问题
# objs += SConscript('src/SConscript', variant_dir="build/src", duplicate=0)

list = os.listdir(cwd)
for d in list:
    path = os.path.join(cwd, d)
    # if os.path.isfile(os.path.join(path, 'SConscript')) and not d == 'src': #不再编译src目录
    if os.path.isfile(os.path.join(path, 'SConscript')):
        objs = objs + SConscript(os.path.join(d, 'SConscript'), variant_dir="build/" + d, duplicate=0)

# 构建可执行文件
bin = env.Program(target = env["project_name"], source = objs )
env.Install(env["build_bin_root"], bin)
```



文件夹目录：

```python
import os

Import('env')
env = env.Clone()

pwd     = os.getcwd()
src     = Glob('*.c')

env.Append(CPPPATH = [pwd])

# group = Library('cjson', src)  #将文件编译成不依赖项目编译参数的库
# group = env.Library('cjson', src) #依赖项目编译参数的库
group = env.Object(src)

Return('group')
```



### 1.3 GCC

gcc交叉编译工具链的命名规则：arch [-vendor] [-os] [-(gnu)eabi] [-gcc]

arch： 体系架构，如 ARM，MIPS

vendor： 工具链提供商，没有 vendor 时，用 none 代替；

os： 目标操作系统，没有 os 支持时，也用 none 代替

eabi： 嵌入式应用二进制接口（Embedded Application Binary Interface）

如果同时没有 vendor 和 os 支持，则只用一个 none 代替。例如 arm-none-eabi 中的 none 表示既没有 vendor 也没有 os 支持。 



根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如

- arm-none-eabi：这个是没有操作系统的，它使用的是newlib这个专用于嵌入式系统的C库。

- arm-none-linux-eabi：用于Linux的，使用Glibc



GCC 循环链接问题的解决：

```makefile
-Wl,--start-group

1*.a 2*.a 

-Wl,--end-group
```

链接参数：

> -L 指定查找链接库的位置
>
> -l 指定链接库名称 (-lc 标准c库 -lm math库)
>
> -T 指定链接脚本



### 1.4 Makefile

Makefile 文件无法在线调试，可以使用 --debug 参数让 make 打印详细的信息来协助理解，或者是在 Makefile 中添加一些打印信息，常用打印方式有两种：

方法1，在makefile中采用如下的语句： 

```makefile
$(info, xxxx$(xxx))
$(warning, xxxx$(xxx))
$(error, xxxx$(xxx))
```

其中，\$(xxx) 表示某个变量。这三个命令可以加到 Makefile 的任意地方，注意 \$(error, xxxx$(xxx)) 会终止 Make 过程。

方法2，在makefile中采用如下语句：

```makefile
@echo "xxxx $xx xxxx"
```

其中，\$(xxx) 表示某个变量。**这个命令只能用在目标后边，且前面是个TAB**。这个就是标准 Makefile 语法中的一个命令。

make 的工作的一些机制：

> a. 如果给出了参数，则 make 优先去找匹配的规则（匹配规则：完整匹配 > 通配符半匹配 > 完全通配符匹配）去执行；如果没有给出参数，make 会自动找到 Makefile 中第一个目标中没有通配符的规则执行。
>
> b. 如果中间遇到 include 其他文件，就会紧接着执行 include 的文件，完成后再继续执行本文件。
> c. make 总是从 Makefile 的开头开始解析，并不是找到匹配目标之后仅执行匹配目标的命令。也就是说，在匹配之前，Make 可能已经解析了很多判断条件。
> d. 对于匹配的规则如果有依赖，优先解析依赖。注意，依赖的匹配也符合 1 中所说的规则。
> e. 命令前面加了 @ 字符，则不显示命令本身而只显示它的结果。命令前面加了 - 号，即使这条命令出错，make 也会继续执行后续命令。
> f. 如果 Makefile 中存在多条同名规则，则 make 程序会尝试将他们合并。但是如果这些同名规则都有命令的话，make 会给出警告，并用后面的命令代替前面的命令。
> 原文链接：https://blog.csdn.net/ZCShouCSDN/article/details/122239526



### 1.5 其他

4.1 消除参数未使用参数告警的方法

```c
#define UNUSED(x) ((void)(x))
```

4.2  编译阶段打印宏的预编译值

```c
#define PRINT_MACRO_HELPER(x)   #x
#define PRINT_MACRO(x)          #x "=" PRINT_MACRO_HELPER(x)

#pragma message(PRINT_MACRO(NUMBER_MACRO))
```

举例：

```c
#include <stdio.h>

#define PRINT_MACRO_HELPER(x)   #x
#define PRINT_MACRO(x)          #x "=" PRINT_MACRO_HELPER(x)

#define NUMBER_MACRO            3.14159
#define STRING_MACRO            "This is a string."

#pragma message(PRINT_MACRO(NUMBER_MACRO))
#pragma message(PRINT_MACRO(STRING_MACRO))
#pragma message(PRINT_MACRO(UNDEF_MACRO))

#define UNUSED(x) ((void)(x))

int test(int para)
{
  UNUSED(para);

  printf("Hello,world!\r\n");
  return 0;
}
```

编译时会打印

> (base) root@PC-202010131037:build_test# gcc -Wunused-parameter -c test.c -o test.o
> 
> test.c:9:9: note: #pragma message: NUMBER_MACRO=3.14159
> 
>     9 | #pragma message(PRINT_MACRO(NUMBER_MACRO))
>    
>       |         ^~~~~~~
>    
> test.c:10:9: note: #pragma message: STRING_MACRO="This is a string."
> 
>    10 | #pragma message(PRINT_MACRO(STRING_MACRO))
>    
>       |         ^~~~~~~
>    
> test.c:11:9: note: #pragma message: UNDEF_MACRO=UNDEF_MACRO
> 
>    11 | #pragma message(PRINT_MACRO(UNDEF_MACRO))
>    
>       |         ^~~~~~~
>    



4.3 写跨平台的项目常常需要在代码中判断平台的类型，加载不同的资源以及使用不同的接口。在不同的平台中编译器中定义了不同的宏。常用的如下

```c
Windows平台
_WIN32 32位和64位系统都有定义
_WIN64 仅64位系统有定义

Unix平台
unix
__unix
__unix__

Mac OS X 平台
__APPLE__
__MACH__

Linux平台
__linux__
linux
__linux
```



## **二、日志篇**

### 2.1 比较常用的C语言预定义宏

```c
__LINE__  ：当前程序行的行号，表示为十进制整型常量

__FILE__  ：当前源文件名，表示字符串型常量

__DATE__ ：转换的日历日期，表示为Mmm dd yyyy 形式的字符串常量

__TIME__  ：转换的时间，表示"hh:mm:ss"形式的字符串型常量，是由asctime产生的。

Gcc/ARMCC 还支持 __func__ 和 __FUNCTION__ (windows下vc6.0编译器不支持)

C++ 中的 __cplusplus
```

小技巧： Vscode 上可以把我们经常定位代码流程打印的代码如

```c
os_kprintf("%s-%d enter\r\n", __func__, __LINE__);
```

定义为代码片段，并起一个简单的缩写，当键入这个缩写时，就会扩展成这句代码。

方法：

 [![p97g4VH.png](https://s1.ax1x.com/2023/05/24/p97g4VH.png)](https://imgse.com/i/p97g4VH)  [![p97gWrD.png](https://s1.ax1x.com/2023/05/24/p97gWrD.png)](https://imgse.com/i/p97gWrD)

然后编辑c.json文件

```json
{
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	"output include": {
		"prefix": "in",
		"body": [
			"#include \"\""
		],
		"description": "input include files"
	}

	"log to c file": {
		"prefix": "osk",
		"body": [
			"os_kprintf(\"=========%s-%d enter=========\\r\\n\", __func__, __LINE__);"
		],
		"description": "quick log"
	}
}
```

  ![osk.gif](https://z4a.net/images/2023/05/24/osk.gif)

网上的一个这种代码片段格式生成小工具 https://snippet-generator.app/ 



### 2.2 undef

有的时候，想关掉某一个文件里的打印，又不想全局关log，就可以在文件开头重新把打印函数作为宏定义给重新定义成空，这样不会改动代码，效率也很高。

\#ifdef DEBUG

\#undef DEBUG

\#endif



### 2.3 函数返回值

函数调用，就一定会有参数和返回值的传递问题，因此也就产生了多种不同的编程范式，比如：

1. Posix 风格：函数返回值只用来表示成功(0)或失败(非0)，其他的输出结果都使用参数来传递。
2. Unix 风格：函数返回值即包括错误代码，也包括有用的输出结果。


## 三、工具篇

### 3.1 **linux子系统**

Windows 都自带了一个linux子系统，这样不用安装虚拟机，就可以很快的通过命令行在这个linux子系统上验证一些功能。

开启方法如下：

1.开启windows的开发者选项

 [![p97gfqe.png](https://s1.ax1x.com/2023/05/24/p97gfqe.png)](https://imgse.com/i/p97gfqe)

2.控制面板中选择“适用于Linux的Windows子系统”

 [![p97gTPI.png](https://s1.ax1x.com/2023/05/24/p97gTPI.png)](https://imgse.com/i/p97gTPI)

3.然后再windows的应用商店中搜索Ubuntu并进行安装

  [![p97g5ad.png](https://s1.ax1x.com/2023/05/24/p97g5ad.png)](https://imgse.com/i/p97g5ad)

4.安装时需要设置linux子系统的账号和密码
[![p97g7Gt.png](https://s1.ax1x.com/2023/05/24/p97g7Gt.png)](https://imgse.com/i/p97g7Gt)

安装完成后，再bash或者powershell中输入bash就可以开启这个安装的只有命令行的ubuntu子系统。



5.wsl 连接外部usb

   - powelshell中安装usbipd-win： 

```powershell
winget install --interactive --exact dorssel.usbipd-win
```

   - 安装用户空间工具和 USB 硬件标识符数据库。 这些说明适用于 Ubuntu

```shell
apt install linux-tools-generic hwdata
   
update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20
```

   - 附加 USB 设备

```shell
usbipd wsl list
usbipd wsl attach --busid 
lsusb
```

   - 解绑

```powershell
usbipd wsl detach --busid 
```


### 3.2 VSCODE

常用的vscode快解键

| 快捷键                  | 操作                                                         | 备注         |
| ----------------------- | ------------------------------------------------------------ | ------------ |
| Ctrl+k，Ctrl+s          | 显示快捷键                                                   |              |
| Ctrl+g                  | 转到某一行                                                   |              |
| **Ctrl+p**              | **转到某个文件**                                             |              |
| Ctrl+TAB                | 切换选项卡                                                   |              |
| Ctrl+l                  | 选择当前行                                                   | 小写的L      |
| Ctrl+shift+L            | 选择所有出现的当前选择                                       |              |
| Ctrl+k, ctrl+x          | 删除尾部空格                                                 |              |
| Shift+alt+f             | 格式化文档                                                   |              |
| F12                     | 转到定义                                                     |              |
| F2                      | 变量重命名                                                   |              |
| **Ctrl+x**              | **删除光标所在的当前行**                                     | **不用选中** |
| **Ctrl+c**              | **复制光标所在的当前行**                                     | **不用选中** |
| **Shift+alt+↑/↓**       | **复制粘贴当前行**                                           |              |
| **Alt+↑/↓**             | **交换上下行**                                               |              |
| Ctrl+shfit+enter        | 在上一行插入                                                 |              |
| **Ctrl+shfit+\\**       | **跳到对应的括号处**                                         |              |
| **Ctrl+[ 或者 ]**       | **缩进**                                                     |              |
| **Ctrl+Home**           | **跳到文件开头**                                             |              |
| **Ctrl+End**            | **跳到文件末尾**                                             |              |
| **Ctrl+shfit+[ 或者 ]** | **折叠或展开代码片段**                                       |              |
| **ctrl+k ctrl+0**       | **折叠文件内所有代码片段**                                   |              |
| **ctrl+/**              | **注释/取消注释本行代码**                                    |              |
| Shift+Alt+a             | C语言文件用 /*  */ 注释代码                                  | 代码块注释   |
| Ctrl+T                  | 展示光标所在位置函数的定义                                   |              |
| **Ctrl+shift+o**        | **跳转到本文件函数等符号定义的位置**                         |              |
| **Alt+→/←**             | **下一步或者上一步**                                         |              |
| **Alt+click**           | **插入光标**                                                 | 列模式       |
| **Ctrl+alt+↑/↓**        | **在上/下方插入光标**                                        |              |
| **Ctrl+alt+→/←**        | **开关新的代码编辑页面**                                     | 分屏         |
| Ctrl+`                  | 打开/关闭terminal                                            |              |
| **ctrl+Y**              | **Redo**                                                     |              |
| **alt+z**               | **切换超出编辑器的代码显示，即多行变一行显示，一行变多行显示** |              |
| **Ctrl+Enter**          | 在当前行下方插入一行                                         |              |



Ctrl+shift+L: 同时选中当前文件的所有选择

 ![ctrl_shfit_L.gif](https://z4a.net/images/2023/05/24/ctrl_shfit_L.gif)

Ctrl+k, ctrl+x : 删除尾部的空格

 ![Ctrl_K_ctrl_x.gif](https://z4a.net/images/2023/05/24/Ctrl_K_ctrl_x.gif)

alt+shift+f 格式化文档

 ![shfit_alt_f.gif](https://z4a.net/images/2023/05/24/shfit_alt_f.gif)

ctrl+k, ctrl+f 格式化选中的代码段

 ![ctrl_K_CTRL_F.gif](https://z4a.net/images/2023/05/24/ctrl_K_CTRL_F.gif)

 ctrl+x 不用选中该行就删除光标所在的行.(同理的有ctrl+c)

![ctrl_x.gif](https://z4a.net/images/2023/05/24/ctrl_x.gif)

alt+↑/↓ （键盘的上下方向键） 将光标所在的行上下移动

 ![alt_up.gif](https://z4a.net/images/2023/05/24/alt_up.gif)

ctrl+shift+\ 跳到对应的括号处

 ![ctrl_shift_slash.gif](https://z4a.net/images/2023/05/24/ctrl_shift_slash.gif)

ctrl+] 向右缩进，ctrl+[向左缩进

 ![ctrl_square_bracket.gif](https://z4a.net/images/2023/05/24/ctrl_square_bracket.gif)

ctrl+k, ctrl+0  折叠代码片段 ctrl+k, ctrl+j  展开代码片段
 ![ctrl_k_ctrl_0.md.gif](https://z4a.net/images/2023/05/24/ctrl_k_ctrl_0.gif)

ctrl+/ 注释行代码

shift+alt+a 添加/* */格式的注释

 [![shiftalta.gif](https://z4a.net/images/2023/05/24/shiftalta.gif)

ctrl+alt+↑/↓ 列模式

 [![ctrl_alt_direction.md.gif](https://z4a.net/images/2023/05/24/ctrl_alt_direction.gif)



vscode综合操作实例：

1. 有的时候在网上复制了一些代码到vscode中，变成了一行，如下:
```
#include <unistd.h>       ssize_t read(int fd, void *buf, size_t count);       ssize_t write(int fd, const void *buf, size_t count);       #include <sys/types.h>       #include <sys/socket.h>       ssize_t send(int sockfd, const void *buf, size_t len, int flags);       ssize_t recv(int sockfd, void *buf, size_t len, int flags);       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                      const struct sockaddr *dest_addr, socklen_t addrlen);       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                        struct sockaddr *src_addr, socklen_t *addrlen);       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);       ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
```

不好查看，可以先使用alt+z 把超出编辑器的代码切换成全部显示到屏幕上。

然后需要把这些代码格式化，直接 shift+alt+f 或者选中后 ctrl+k,ctrl+f 都不好使。可以先把空格替换成'\n'（搜索时需要勾上正则表达式），然后就变成了成多行代码。

接着使用  shift+alt+f 或者选中后 ctrl+k,ctrl+f  格式化这些代码（格式化代码时会删除行尾的空格）。

最后把符合正则表达式 ^\s*(?=\r?$)\n 的格式替换成空（删除空行，vscode只勾选正则表达式）

 ![vscode_demo.gif](https://z4a.net/images/2023/05/24/vscode_demo.gif)



#### 3.2.1 格式化插件 clang-format

Ctrl+, 打开配置，搜索format。

1）可以勾选Format on save时会在保存文件时对文件进行格式化。

2）否则快捷键 alt+shift+f 时会格式化文件，ctrl+K，ctrl+F 可以格式化勾选的代码片段。

规则为vscode代码根目录下的.clang-format文件，如下为gitee上我司开源代码的format规则文件


```
---
Language:        Cpp
# BasedOnStyle:  LLVM
AccessModifierOffset: -2
AlignAfterOpenBracket: Align
AlignConsecutiveMacros: true
AlignConsecutiveAssignments: true
AlignConsecutiveDeclarations: true
AlignEscapedNewlines: Right
AlignOperands: true
AlignTrailingComments: true
AllowAllArgumentsOnNextLine: false
AllowAllConstructorInitializersOnNextLine: false
AllowAllParametersOfDeclarationOnNextLine: false
AllowShortBlocksOnASingleLine: false
AllowShortCaseLabelsOnASingleLine: false
AllowShortFunctionsOnASingleLine: None
AllowShortLambdasOnASingleLine: All
AllowShortIfStatementsOnASingleLine: Never
AllowShortLoopsOnASingleLine: false
AlwaysBreakAfterDefinitionReturnType: None
AlwaysBreakAfterReturnType: None
AlwaysBreakBeforeMultilineStrings: false
AlwaysBreakTemplateDeclarations: MultiLine
BinPackArguments: false
BinPackParameters: false
BraceWrapping:
  AfterCaseLabel:  true
  AfterClass:      true
  AfterControlStatement: true
  AfterEnum:       true
  AfterFunction:   true
  AfterNamespace:  true
  AfterObjCDeclaration: false
  AfterStruct:     true
  AfterUnion:      true
  AfterExternBlock: false
  BeforeCatch:     true
  BeforeElse:      true
  IndentBraces:    false
  SplitEmptyFunction: true
  SplitEmptyRecord: true
  SplitEmptyNamespace: false
BreakBeforeBinaryOperators: None
BreakBeforeBraces: Custom
BreakBeforeInheritanceComma: false
BreakInheritanceList: BeforeColon
BreakBeforeTernaryOperators: true
BreakConstructorInitializersBeforeComma: false
BreakConstructorInitializers: BeforeColon
BreakAfterJavaFieldAnnotations: false
BreakStringLiterals: true
ColumnLimit:     120
CommentPragmas:  '^ IWYU pragma:'
CompactNamespaces: false
ConstructorInitializerAllOnOneLineOrOnePerLine: false
ConstructorInitializerIndentWidth: 4
ContinuationIndentWidth: 4
Cpp11BracedListStyle: true
DerivePointerAlignment: false
DisableFormat:   false
ExperimentalAutoDetectBinPacking: false
FixNamespaceComments: true
ForEachMacros:
  - foreach
  - Q_FOREACH
  - BOOST_FOREACH
IncludeBlocks:    Preserve
IncludeCategories:
  - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
    Priority:        3
  - Regex:           '^(<|"(gtest|gmock|isl|json)/)'
    Priority:        2
  - Regex:           '.*'
    Priority:        1
IncludeIsMainRegex: '(Test)?$'
IndentCaseLabels: false
IndentPPDirectives: None
IndentWidth:     4
IndentWrappedFunctionNames: false
JavaScriptQuotes: Leave
JavaScriptWrapImports: true
KeepEmptyLinesAtTheStartOfBlocks: true
MacroBlockBegin: ''
MacroBlockEnd:   ''
MaxEmptyLinesToKeep: 1
NamespaceIndentation: None
ObjCBinPackProtocolList: Auto
ObjCBlockIndentWidth: 2
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: true
PenaltyBreakAssignment: 2
PenaltyBreakBeforeFirstCallParameter: 19
PenaltyBreakComment: 300
PenaltyBreakFirstLessLess: 120
PenaltyBreakString: 1000
PenaltyBreakTemplateDeclaration: 10
PenaltyExcessCharacter: 1000000
PenaltyReturnTypeOnItsOwnLine: 60
PointerAlignment: Right
ReflowComments:  true
SortIncludes:    false
SortUsingDeclarations: true
SpaceAfterCStyleCast: false
SpaceAfterLogicalNot: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeCpp11BracedList: false
SpaceBeforeCtorInitializerColon: true
SpaceBeforeInheritanceColon: true
SpaceBeforeParens: ControlStatements
SpaceBeforeRangeBasedForLoopColon: true
SpaceInEmptyParentheses: false
SpacesBeforeTrailingComments: 4
SpacesInAngles:  false
SpacesInContainerLiterals: true
SpacesInCStyleCastParentheses: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
Standard:        Cpp11
StatementMacros:
  - Q_UNUSED
  - QT_REQUIRE_VERSION
TabWidth:        4
UseTab:          Never
...
```



#### 3.2.2 配置终端为oneos-cube

配置终端设置 -->  Automation Profile:Window (在setting json中编辑)

```
"terminal.integrated.profiles.windows": {
...
"OneOS-Cube": {
  "path": [
    "D:\\software\\OneOSCube\\components\\cmder\\OneOS-Cube.exe"
  ],
  "args": [],
}
}


```



#### 3.3.3 插件

Gitlens  -- 一个git扩展

Hex Editor  -- hex文件查看

highlight-words -- 高亮代码

Indent-Rainbow -- 以不同颜色展示缩进的扩展

Better Comments 

Code Spell Checker

3.3.4 文件排除

如果有的文件找不到，有可能是被vscode按照gitignore的规则排除了，可以勾选这个选项避免被gitignore的文件不被搜索到

[![vscode_search_ignore.png](https://z4a.net/images/2023/07/21/vscode_search_ignore.png)](https://z4a.net/image/VBDS2C)





### 3.3 窗口置顶或者截图置顶

推荐一个全局手势工具 [WGestures](http://www.yingdev.com/projects/wgestures) （可以置顶窗口）或者 [snipaste](https://zh.snipaste.com/) （很好用的截图工具，按下 `F1` 来开始截图，再按 `F3`，截图就在桌面置顶显示了）

 [![p97gRKO.jpg](https://s1.ax1x.com/2023/05/24/p97gRKO.jpg)](https://imgse.com/i/p97gRKO)  

 ![wgestures_ontop.jpg](https://z4a.net/images/2023/05/24/wgestures_ontop.jpg)

 [![p97ggxK.jpg](https://s1.ax1x.com/2023/05/24/p97ggxK.jpg)](https://imgse.com/i/p97ggxK)

### 3.4 Git

git cherry-pick用于把另一个本地分支的commit修改应用到当前分支。

简单用法：


- git cherry-pick <commit id>

- git remote add myown git@xxx.git //添加远程仓库为myown

- git branch --set-upstream-to=origin/remote_branch your_branch

- git branch -u origin/remote_branch

其中，origin/remote_branch是你本地分支对应的远程分支；your_branch是你当前的本地分支。


git规则

.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的

解决办法

A.

```
git rm -r --cached .
git add .
git commit -m 'update .gitignore'
```

 

B.

```
git rm --cached file/path/to/be/ignored。
git add .
git commit -m "fixed untracked files"
```

 

git clone 指定分支

```
git clone -b dev_jk git@xxx.git
```

删除当前目录下所有没有track过的文件和文件夹. 不管他是否是.gitignore文件里面指定的文件夹和文件

```
git clean -xfd
```



远程已有remote_branch分支但未关联本地分支local_branch且本地已经切换到local_branch

```
git push -u origin/remote_branch
```

远程没有remote_branch分支并，本地已经切换到local_branch

```
 git push origin local_branch:remote_branch
```



文件没有改动但status显示又很多文件被改动了，是因为文件模式被改动了。取消检查文件模式改动

```
git config --global --add core.filemode false
```

如果不起作用

使用git config --list 查看一下，是否修改掉，如果有多条，把他们都替换掉

```
git config --replace-all core.filemode false
```







### 3.5 局域网文件传输

本地http 服务器

执行如下命令，可以在本地(127.0.0.1)启动一个端口号为8000的http服务
```
python -m http.server 
```

可以使用http://127.0.0.1:8000 访问这个http服务，页面为启动这个服务下文件列表

可以通过这个方法局域网传输一些文件


### 3.6 GDB调试

编译时添加编译选项 -g 后，程序就携带了调试符号信息。

启动gdb调试有三种方法：

1） gdb filename

2） gdb attach pid

某些场景下，程序启动了，但我们想调试该程序，又不想重启这个程序，就可以先获得这个程序的pid，使用 gdb attach pid 来调试

例如:

```shell
gcc -g ctime_test.c
```

```shell
./a.out &
```

```shell
(base) root@PC-202010131037:time_test# ps
  PID TTY          TIME CMD
   15 pts/0    00:00:00 bash
  220 pts/0    00:00:01 a.out
  221 pts/0    00:00:00 ps
```

```
gdb attach 220
```

3)  方法三 进程 Crash 之后如何定位问题——调试 core 文件

```
gdb filename corename
```

```
gdb a.out core
```



常用命令补充

tbreak 临时断点，一旦该断点触发后会自动删除

watch 监视变量或者内存，每当该处的值有变化时，就会中断程序

display 该命令监视的变量或者内存的值，每次程序中断都会打印

条件断点  

```
break [lineNo] if [condition]
```

添加条件断点，还有一个方法就是先添加一个普通断点，然后使用 **condition 断点编号 断点触发条件** 这样的格式来添加。

4) gdb tui 模式

a. ctrl+x, a 打开/关闭source串口

b. layout src / asm 打开源码/汇编窗口

c. layout split

d. ctrl+n / ctrl+p 切换焦点

[![p97cbB4.jpg](https://s1.ax1x.com/2023/05/24/p97cbB4.jpg)](https://imgse.com/i/p97cbB4)



### 3.7 Spacevim

一些快捷键

| `SPC f v d` | 打开 SpaceVim 的用户配置文件 |
| ----------- | ---------------------------- |
|             |                              |

   

### 3.8 python

#### 3.8.1 miniconda

Conda 是一个是为 Python 而设的开源包管理系统和环境管理系统，用于安装 Python 及相应的包（库），其实就是 Python 环境安装、运行、管理平台，也就是说，Conda 已经附带有了 Python，安装了它就不需要另外安装 Python 了。

之所以选择安装 Conda 来代替单独安装 Python，是因为：单独安装 Python 后，当需要安装其他包（库），特别是第三方包（库）的时候，Python 的包管理工具 pip 在下载安装包过程中往往会出现这样或那样的问题，比如会忽略某个包的其他依赖包，这样会造成该包在安装后不能使用的情况，这就是大家经常吐槽的所谓的各种“坑”；而利用 Conda 来安装这些软件包就可以避免出现这些错误。

Conda 分为 Anaconda 和 Miniconda 两个版本，两个都是开源（免费）的。其中 Anaconda 可以说是 Conda 的大型版本，安装了很多的软件包；而 Miniconda 是 Conda 的最小安装程序（即Conda 的迷你版），可以说是 Anaconda 的一个简化版本，只包含 conda、Python 及其依赖的包，以及其他少量常用的包。

1. 安装 miniconda

```
linux 

wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh
```



2. 配置源

```
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/              
```

3. 创建环境

```
conda create --name py39 python=3.9
```

4. 激活环境             

```
# 安装好后，使用activate激活某个环境
activate py35 #for Windows  

# for Linux & Mac
source activate py35
或者 conda activate py35
```

5. 删除环境

```
conda remove --name py35 --all          
```

​    

6. 查看系统中的所有环境

```
conda info -e
```

7. 包管理

```
conda list

conda install
```

8. 退出虚拟环境

```
linux: 
conda deactivate 

windows: 
deactivate your_env_name    
```

#### 3.8.2 格式化输出

​	使用+号拼接字符串

```python
name = 'jack'
slogan = 'bingo'
age = 24

print( jack + ' says: ' + slogan + ', age: ' + age)
```

占位符 

```python
print(" %s says %s, age: %d" %(jack, slogan, age))
```

其中%s、%d便是占位符，作用就是替后面的变量站住这个位置，字符串后面的%是一个特殊的操作符，该操作符会将后面的变量值，替换掉前面字符串中的占位符。

对比两种写法，会发现使用占位符可以:

将字符串中用到变量集中在一起，方便查找和修改

避免了反复使用引号，导致的引号对应识别困难

能够更直接通顺的看出句子的内容



目前常用的占位符写法有三种

1.% 占位符

语法格式如下：

```python
"... %[key][flags][width][.precision][length type]conversion type ..." % values
```

依次介绍下上面占位符每个符号每个字段的意思

- %: 必须要有的符号。它标记占位符的开始。
- key: 选填。映射的键，由带括号的字符序列组成，一般用于后面的values是是字典的场景。
- flags: 选填。转换标志(Conversion flags), 会影响某些转换类型的结果。
- width: 选填。最小字段宽度。如果指定为“*”（星号），则实际宽度从值中元组的下一个元素读取，要转换的对象位于最小字段宽度和可选精度之后。*
- *precision: 选填。精度，写法为.precision（点+精度）。如果指定为“*”（星号），则实际宽度从值中元组的下一个元素读取，要转换的值位于精度之后。
-  length type: 选填。长度修改器。
- Conversion type: 必须要有的符号。转换类型，也标记占位符的开始。   

下面依次使用一个小示例展示下上面每个字段的用法

Conversion type
   由于这个字段是必选字段，所以最先介绍（%写法是固定的，Conversion type则必须要选择一个转换类型）
   类型有很多，只介绍三个非常常用的，（更多的建议查阅官方文档：printf-style-string-formatting）

2.format语句

```python
print('{} {}'.format('hello','world')) 

print('{0} {1} {0}'.format('hello','world'))

print('{a} {a} {b}'.format(a = 'hello', b = 'world'))

print('{:b}'.format(20))

print('0x{:x}'.format(20))

print('{:e}'.format(20))

print('{:%}'.format(0.10))
```

> 结果：
>
> hello world
> 
> hello world hello
> 
> hello hello world
> 
> 10100
> 
> 0x14
> 
> 2.000000e+01
> 
> 10.000000%}
> 

   

3.f表达式

f-string用大括号 `{}` 表示被替换字段，其中直接填入替换内容

```python
name = 'Eric'
print(f'Hello, my name is {name}')

age = 18
print(f"""
My name is {name},
age {age}
""")

import datetime
e = datetime.datetime.today()
print(f'the time is {e:%Y-%m-%d (%a) %H:%M:%S}')   # datetime时间格式
```

> 输出结果：
>
> Hello, my name is Eric
>
> My name is Eric,
> age 18
>
> the time is 2023-05-23 (Tue) 21:40:34


## 四、通用的C语言代码库篇

### 4.1 安全的C函数

缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区，又被称为“堆栈”，在各个操作进程之间，指令会被临时储存在“堆栈”当中，“堆栈”也会出现缓冲区溢出。缓冲区溢出攻击是利用缓冲区溢出漏洞所进行的攻击行动。利用缓冲区溢出攻击，可以导致程序运行失败、系统关机、重新启动等后果。

缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务分段错误（Segmentation fault），另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。

C语言没有提供字符串类型，字符串以字符数组的形式出现，C标准库提供了一些操作字符串的函数，主要有：

strcmp 字符串比较函数，

strcpy 字符串拷贝函数，

strcat字符串连接函数，

sprintf格式化字符串拷贝函数等等。

因为字符串就是以‘\0’结束的一段内存，这些函数实质上也就是操作内存的函数。



不安全函数的替代

#### 4.1.1 函数gets  -->  fgets

```
头文件：
#include <stdio.h>

函数原型：
char *gets(char *buff);

函数说明：
从stdin流中读取字符串，直至接受到换行符或EOF时停止，并将读取的结果存放在buffer指针所指向的字符数组中。但换行符会被丢弃，然后在末尾添加'\0'字符，并由此来结束字符串。
```

【缓冲区溢出错误】读入stdin流中的字符串超过buff长度造成溢出。

错误代码：

```c
void main()
{
    char buf[1024];
    gets(buf);
}
//当输入内容超过1024大小
```



#### 4.1.2 strcpy --> strncpy

```c
头文件：
#include <string.h>

函数原型：
char *strcpy(char *dest, const char *src);

函数说明：
把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。】
```

不可以重叠是因为有可能造成拷贝的时候死循环，这从strcpy函数的实现原理可以看出。

实现原理：

```c
#include <stdio.h>
#include <assert.h> 
#include <string.h> 

char* strcpy(char *strDest, const char *strSrc) //const
{
    assert((strDest!=NULL) && (strSrc !=NULL));
    char *address = strDest;             
    while( (*strDest++ = *strSrc++) != '\0' )     
       ;

    return address ;
}
```

【缓冲区溢出错误】源字符串strSrc的字符数目大于目的字符串strDest的buff长度。

```
头文件：
#include <string.h>

函数原型：
char *strncpy(char *dest, const char *src, size_t n);

函数说明：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间。最多复制n个字符。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。】
```

实现原理

```c
// vc6.0 source
char * __cdecl strncpy (
        char * dest,
        const char * source,
        size_t count
        )
{
    char *start = dest;
    while (count && (*dest++ = *source++))   /* copy string */
    	count--;

    if (count)                /* pad out with zeroes */
    	while (--count)
    		*dest++ = '\0';

    return(start);
}
```

一个最常见的问题，就是strncpy 并不帮你保证‘/0’结束。所以strncpy更像是特殊的memcpy。

正确使用方法【建议】：

```c
strncpy(dst, src, dst_size-1);
dst[dst_size-1] = '\0'; /* Always do this to be safe! */
```

#### 4.1.3  strdup --> strndupa

 如果是为了复制一个字符串，那么更好的做法是使用 strdup 函数

```c
char* strdup(const char *s);
```

strdup 函数会调用 malloc 分配足够长度的内存并返回。

【特别注意】在你不使用的时候 free 它。

 

如果只是函数内部调用这个字符串，可以使用 strdupa 函数。

```c
char* strndupa(const char *s, size_t n);
```

 最多复制n个字符到栈内存分配的空间，并再在结尾增加一个'\0'。不用释放。

说明：strndupa 函数调用 alloca函数而非 malloc 函数分配内存，alloca 分配的内存是 桟内存而非堆内存。所以当函数返回后，内存就自动释放了，不需要 free。



#### 4.1.4  strcat --> strncat

```c
头文件：
#include <string.h>

函数原型：
char *strcat(char *dest, const char *src);

函数说明：
把src所指字符串添加到dest结尾处(覆盖dest结尾处的'\0')并添加'\0'。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串】
```

 

```c
头文件：
#include <string.h>

函数原型：
char *strncat(char *dest, const char *src, size_t n);

函数说明：
把src所指字符串的前n个字符或'\0'之前的字符添加到dest结尾处(覆盖dest结尾处的'\0')并添加'\0'。【src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串】
```

 

使用建议

```c
strncat(dest, source, dest_size-strlen(dest)-1);
```

#### 4.1.5  sprintf --> snprintf

```c
头文件：
#include <stdio.h>

函数原型：
int sprintf(char *buffer, const char *format, ...);

参数列表:
buffer：char型指针，指向将要写入的字符串的缓冲区
format：格式化字符串
[argument]...：可选参数，可以是任何类型的数据

返回值：字符串长度（strlen）
功能:把格式化的数据写入某个字符串缓冲区
```

 

```c
头文件：
#include <stdio.h>

函数原型：
int snprintf(char *buffer, size_t size, const char *format, ...);

参数列表:
buffer：char型指针，指向将要写入的字符串的缓冲区
size：最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个'\0'
format：格式化字符串
[argument]...：可选参数，可以是任何类型的数据

返回值：若成功则返回“欲”写入的字符串长度，若出错则返回负值
```

 特别注意返回值，与sprintf不同，如果输出因为size的限制而被截断，返回值将是“如果有足够空间存储，所应能输出的字符数(不包括字符串结尾的'/0')”，这个值和size相等或者比size大！也就是说，如果可以写入的字符串是 "0123456789ABCDEF" 共16位，但是size限制了是10，这样 snprintf() 的返回值将会是16 而不是 10 ！并且，如果返回值等于或者大于size，则表明输出字符串被截断了(truncated)。

 

错误示例：

```c
char buff[10]={0}; 
char str[] = "123456789012345678";
snprintf(buff, sizeof(buff), str); //如果后面的字符串str中有%s等转义字符，则会继续往后读取。
```

 

正确示例：

```c
char buff[10]={0}; 
char str[] = "123456789012345678";
snprintf(buff, sizeof(buff), "%s", str); //严格规范，结果是"123456789"
```

 

### 4.2 cJSON

在使用文件系统读取、存储一些文件时，建议可以使用json的文件格式，这样解析文件内容非常清晰易懂，cJSON这个组件使用起来也非常简单。 

Json格式化在线工具https://c.runoob.com/front-end/53/

#### 4.2.1  JSON语法规则

JSON对象是一个无序的"名称/值"键值对的集合：

- 以"{“开始，以”}"结束，允许嵌套使用
- 每个名称和值成对出现，名称和值之间使用":"分隔
- 键值对之间用","分隔
- 在这些字符前后允许存在无意义的空白符

对于键值，可以有如下值：

- 一个新的json对象
- 数组：使用"[“和”]"表示
- 数字：直接表示，可以是整数，也可以是浮点数
- 字符串：使用引号"表示
- 字面值：false、null、true中的一个(必须是小写)

示例如下：

```json
{
  "wifi_info": [
    {
      "ssid": "test",
      "passwd": "cmiot123"
    }
  ]
}
```

#### 4.2.2  cJSON 

git clone https://github.com/DaveGamble/cJSON.git

cJSON的源码文件只有两个：cJSON.h   cJSON.c

#### 4.2.3  cJSON数据封装

封装JSON数据的过程，其实就是创建链表和向链表中添加节点的过程。

① 创建头指针：

```c
cJSON* cjson_test = NULL;
```

② 创建头结点，并将头指针指向头结点：

```c
cjson_test = cJSON_CreateObject();
```

③ 向链表中添加节点：

```c
cJSON_AddNullToObject(cJSON * const object, const char * const name);

cJSON_AddTrueToObject(cJSON * const object, const char * const name);

cJSON_AddFalseToObject(cJSON * const object, const char * const name);

cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);

cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);

cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);

cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw);

cJSON_AddObjectToObject(cJSON * const object, const char * const name);

cJSON_AddArrayToObject(cJSON * const object, const char * const name);
```

#### 4.2.4  输出JSON数据

上面讲述，一段完整的JSON数据就是一条长长的链表，那么，如何打印出这段JSON数据呢？

cJSON提供了一个API，可以将整条链表中存放的JSON信息输出到一个字符串中：

```c
(char *) cJSON_Print(const cJSON *item);
```

使用的时候，只需要接收该函数返回的指针地址即可。

#### 4.2.5  cJSON数据解析

解析方法: 解析JSON数据的过程，其实就是剥离一个一个链表节点(键值对)的过程。

解析方法如下：

① 创建链表头指针：

```c
cJSON* cjson_test = NULL;
```

② 解析整段JSON数据，并将链表头结点地址返回，赋值给头指针。

解析整段数据使用的API只有一个：

```c
(cJSON *) cJSON_Parse(const char *value);
```

③ 根据键值对的名称从链表中取出对应的值，返回该键值对(链表节点)的地址

```c
(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);
```

④ 如果JSON数据的值是数组，使用下面的两个API提取数据：

```c
(int) cJSON_GetArraySize(const cJSON *array);

(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);
```

#### 4.2.6 cJSON使用过程中的内存问题

cJSON提供了如下两个接口函数来删除对象。

```c
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item);

CJSON_PUBLIC(void) cJSON_free(void *object);
```

cJSON_Delete();是用来释放json对象的，CJSON_free();是用来释放其他对象的.

当使用 cJSON_Create* 这类的函数创建的对象（如cJSON *cJSON_CreateObject(void);），需要使用cJSON_Delete来进行删除。该函数删除一条JSON数据时，如果有嵌套，会连带删除。

当调用这两个函数将对象转化为字符串时，需要使用CJSON_free来释放内存

```c
CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item);
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item);
```

例如：

```c
cJSON* wifi_config_json = NULL;
cJSON* info_array , *info_item, *new_item;
char*  info_str = NULL;
char*  read_buf = NULL;

wifi_config_json = cJSON_Parse(read_buf);
if( wifi_config_json ) {
info_array = cJSON_GetObjectItem(wifi_config_json, "wifi_info");
if( info_array ) {
    wifi_info_item_size = cJSON_GetArraySize(info_array);

    for( cnt = 0; cnt < wifi_info_item_size; cnt++ ) {
        info_item  = cJSON_GetArrayItem(info_array, cnt);
        temp_ssid  = cJSON_GetObjectItem(info_item, "ssid")->valuestring;
        temp_passwd = cJSON_GetObjectItem(info_item, "passwd")->valuestring;
        // ithPrintf("temp_ssid: %s, temp_ssid: %s\r\n", temp_ssid, temp_passwd);
        if( strncmp(temp_ssid, new_wifi_info->ssid, strlen(new_wifi_info->ssid)) == 0 ) {
            cJSON_DeleteItemFromArray(info_array, cnt);
            new_wifi_info->info_cnt--;
            ithPrintf("temp_ssid: %s, temp_ssid: %s, cnt: %d\r\n", temp_ssid, temp_passwd, cnt);
            break;
        }
    }

    if( (cnt == wifi_info_item_size) && (cnt > MAX_SAVE_WIFI_CONFIG_NUM) ) {
        cJSON_DeleteItemFromArray(info_array, 0);
        new_wifi_info->info_cnt--;
        ithPrintf("wifi config file cnt = %d > max(%d), delete the first one\r\n",
            cnt, MAX_SAVE_WIFI_CONFIG_NUM);
    }
    
    new_item = cJSON_CreateObject();
    cJSON_AddStringToObject(new_item, "ssid", new_wifi_info->ssid);
    cJSON_AddStringToObject(new_item, "passwd", new_wifi_info->passwd);
    cJSON_AddItemToArray(info_array, new_item);
    new_wifi_info->info_cnt++;
    ret = 0;
}
    
info_str = cJSON_PrintUnformatted(wifi_config_json);
cJSON_Delete(wifi_config_json);

if( info_str != NULL ) {
	cJSON_free(info_str);
}
```

### 4.3 Time

#### 4.3.1 时间概念

- UTC （**Coordinated Universal Time**，协调世界时），又称世界标准时间，也即格林威治标准时间(Greenwich Mean Time,GMT)。中国内地的时间与UTC得时差为+8，也即UTC+8，美国为UTC-5。
- 日历时间，是用"从一个标准时间点到此时的时间经过的秒数"来表示的时间。标准时间点对不同编译器可能会不同，但对一个编译系统来说，标准时间是不变的。一般是表示距离UTC时间 1970-01-01 00:00:00的秒数。

time.h 头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数

**四个变量类型**

- size_t           无符号整数类型
- clock_t         存储处理器时间的类型，unsigned long
- time_t          存储日历时间的类型，和处理器相关的变量
- struct tm

定义的结构体如下：

```c
struct tm
{
  int tm_sec;     /* 秒，范围从 0 到 59    */
  int tm_min;     /* 分，范围从 0 到 59    */
  int tm_hour;    /* 小时，范围从 0 到 23   */
  int tm_mday;    /* 一月中的第几天，范围从 1 到 31   */
  int tm_mon;     /* 月，范围从 0 到 11(注意)       */
  int tm_year;    /* 自 1900 年起的年数            */
  int tm_wday;    /* 一周中的第几天，范围从 0 到 6    */
  int tm_yday;    /* 一年中的第几天，范围从 0 到 365  */
  int tm_isdst;   /* 夏令时                        */
};
```

**两个宏**

NULL	                      这个宏是一个空指针常量的值。

CLOCKS_PER_SEC	这个宏表示每秒的处理器时钟个数。
用于将clock()函数的结果转化为以秒为单位的量，这个量的具体值是与操作系统相关的，通常为1000。

#### 4.3.2 库函数



**clock函数**
函数原型： clock_t clock(void)

函数返回：返回clock函数执行起（一般为程序的开头），处理器时钟所使用的时间

函数功能：用来计算程序或程序的某一段的执行时间

实例

```c
#include<stdio.h>
#include<time.h>

int main()
{
    clock_t start_t,finish_t;
    double total_t = 0;
    int i = 0;
    start_t = clock();
    for(;i<100000;++i)
    {
        //do someting;
    }
    finish_t = clock();
    total_t = (double)(finish_t - start_t) / CLOCKS_PER_SEC;//将时间转换为秒

    printf("CPU 占用的总时间：%f\n", total_t);
    return 0;

}
```



**time函数**
函数原型: time_t time(time_t *timer)

参数说明: 

timer=NULL时得到当前日历时间（从1970-01-01 00:00:00到现在的秒数）

timer=时间数值时，用于设置日历时间，time_t是一个unsigned long类型。如果 timer不为空，则返回值也存储在变量 timer中。

函数功能: 得到当前日历时间或者设置日历时间

函数返回: 当前日历时间

实例

```c
#include <stdio.h>
#include <time.h>

int main ()
{
  time_t seconds;

  seconds = time(NULL);
  printf("自 1970-01-01 起的小时数 = %ld\n", seconds/3600);

  return(0);
}
```



**asctime函数**
函数原型: char* asctime(struct tm * ptr)

函数功能:将结构struct tm * ptr所表示的时间以字符串表示

函数返回: 返回的时间字符串格式为：星期,月,日,小时:分:秒,年

参数说明: 结构指针ptr应通过函数localtime()或gmtime()得到

实例

```c
#include <stdio.h>
#include <time.h>

int main() 
{
  struct tm now;

  now.tm_sec = 10;
  now.tm_min = 9;
  now.tm_hour = 8;
  now.tm_mday = 7;
  now.tm_mon = 6;
  now.tm_year = 120;
  now.tm_wday = 4;

  printf("%s\n", asctime(&now)); // Thu Jul  7 08:09:10 2020
}
```



**localtime函数**
函数原型: struct tm *localtime(const time_t *timer)

函数功能: 使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示。

函数返回: 以tm结构表达的时间

实例

```c
#include <stdio.h>
#include <time.h>

int main ()
{
   time_t timer;
   struct tm *Now;

   time( &timer );
   Now = localtime( &timer );
   printf("当前的本地时间和日期：%s", asctime(Now));

   return(0);
}
```



**ctime函数**
函数原型: char *ctime(const time_t * timer)

函数功能: 将日历时间参数timer转换为一个表示本地当前时间的字符串

函数返回: 返回字符串格式：星期,月,日,小时:分:秒,年

参数说明: timer参数应由函数time获得，其等价于 astime( localtime(timer) )

实例

```c
#include <stdio.h>
#include <time.h>

int main ()
{
    time_t curtime;

    time(&curtime);
    printf("当前时间 = %s", ctime(&curtime));

    return(0);
}
```

**difftime函数**
函数原型: double difftime(time_t time2, time_t time1)

函数功能: 得到两次机器时间差，单位为秒

函数返回: 时间差，单位为秒

参数说明: time1,time2分别表示两个不同的机器时间，该参数应使用time函数获得

实例

```c
#include <time.h>  
#include <stdio.h>  
int main()  
{  
    time_t first,second;

    time(&first);
    sleep(5); 
    time(&second);
    printf("the diff time is: %f seconds", difftime(second,first));  //the diff time is 5.000000 seconds

    return 0;  
}  
```



**gmtime函数**
函数原型: struct tm *gmtime(time_t *timer)

函数功能: 得到以结构tm表示的时间信息，并用格林威治标准时间表示

函数返回: 以结构tm表示的时间信息指针

参数说明: timer用函数time()得到的时间信息

实例

```c
#include <stdio.h>
#include <time.h>

#define BST (+1)
#define CCT (+8)

int main ()
{

   time_t rawtime;
   struct tm *info;

   time(&rawtime);
   /* 获取 GMT 时间 */
   info = gmtime(&rawtime );

   printf("当前的世界时钟：\n");
   printf("伦敦：%2d:%02d\n", (info->tm_hour+BST)%24, info->tm_min);
   printf("中国：%2d:%02d\n", (info->tm_hour+CCT)%24, info->tm_min);

   return(0);
}
```



**mktime函数**
函数原型：time_t mktime(struct tm *timeptr)

函数功能：将时间转换为自1970年1月1日以来逝去时间的秒数

函数返回：该函数返回一个 time_t 值，该值对应于以参数传递的日历时间。如果发生错误，则返回 -1 值。

实例

```c
#include <stdio.h>
#include <time.h>

int main() {
  int ret;
  struct tm info;
  char buffer[80];

  info.tm_year = 2023 - 1900;
  info.tm_mon = 3 - 1;
  info.tm_mday = 17;
  info.tm_hour = 16;
  info.tm_min = 22;
  info.tm_sec = 10;
  info.tm_isdst = -1;

  ret = mktime(&info);
  if (ret == -1) {
    printf("Error\n");
  } else {
    strftime(buffer, sizeof(buffer), "%c", &info);
    printf("%s, ret: %u\n", buffer, ret); //Fri Mar 17 16:22:10 2023, ret: 1679041330
  }

  return 0;
}
```

**strftime函数**
函数原型: size_t strftime( char *strDest, size_t maxsize, const char *format, const struct tm *timeptr);

函数功能: 根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向 strDest中存放maxsize个字符。

参数说明: 转化结果存在s中，最多maxsize个字符写到s中

函数返回: 该函数返回向strDest指向的字符串中放置的字符数（不包括'\0'），如果字符数多于maxsize，函数返回0。

实例

```c
/*format如下：它们是区分大小写的。
    %a 星期几的简写
    %A 星期几的全称
    %b 月分的简写
    %B 月份的全称
    %c 标准的日期的时间串
    %C 年份的后两位数字
    %d 十进制表示的每月的第几天
    %D 月/天/年
    %e 在两字符域中，十进制表示的每月的第几天
    %F 年-月-日
    %g 年份的后两位数字，使用基于周的年
    %G 年分，使用基于周的年
    %h 简写的月份名
    %H 24小时制的小时
    %I 12小时制的小时
    %j 十进制表示的每年的第几天
    %m 十进制表示的月份
    %M 十时制表示的分钟数
    %n 新行符
    %p 本地的AM或PM的等价显示
    %r 12小时的时间
    %R 显示小时和分钟：hh:mm
    %S 十进制的秒数
    %t 水平制表符
    %T 显示时分秒：hh:mm:ss
    %u 每周的第几天，星期一为第一天 （值从0到6，星期一为0）
    %U 第年的第几周，把星期日做为第一天（值从0到53）
    %V 每年的第几周，使用基于周的年
    %w 十进制表示的星期几（值从0到6，星期天为0）
    %W 每年的第几周，把星期一做为第一天（值从0到53）
    %x 标准的日期串
    %X 标准的时间串
    %y 不带世纪的十进制年份（值从0到99）
    %Y 带世纪部分的十进制年份
    %z，%Z 时区名称，如果不能得到时区名称则返回空字符。
    %% 百分号
*/  

include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;
  struct tm *info;
  char buffer[80];

  time(&rawtime);
  info = localtime(&rawtime);

  strftime(buffer, sizeof(buffer), "%Y-%m-%e %H:%M:%S", info);  // 2023-03-17 16:55:50
  printf("%s\n", buffer);

  return 0;
}
```

### 4.4 C语言嵌入汇编

#### 4.4.1 简单的内嵌汇编

```assembly
__asm__ __volatile__("hlt");
```

 "\_\_asm\_\_"表示后面的代码为内嵌汇编，"\_\_volatile\_\_"表示编译器不要优化代码，后面的指令 保留原样。括号里面是汇编指令。



#### 4.4.2 内嵌汇编举例

使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如在下面的汇编语句：  

```assembly
__asm__ __violate__ ("movl %1,%0" : "=r" (result) : "m" (input));
```

- "movl %1,%0"是指令模板；"%0"和"%1"代表指令的操作数，称为占位符，内嵌汇编靠它们将C 语言表达式与指令操作数相对应。
- 指令模板后面用小括号括起来的是语言表达式，本例中只有两个："result"和"input"，他们按照出现的顺序分 别与指令操作数"%0"，"%1"对应；注意对应顺序：第一个表达式对应"%0"；第二个表达式对应"%1"，依次类推，操作数至多有10 个，分别用"%0","%1"...."%9"表示。
- 在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。 "result"前面的限制字符串是"=r"，其中"="表示"result"是输出操作数，"r" 表示需要将"result"与某个通用寄存器相关联，先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是"result"本身，当然指令执行 完后需要将寄存器中的值存入变量"result"，从表面上看好像是指令直接对"result"进行操作，实际上GCC做了隐式处理，这样我们可以少写一 些指令。
- "input"前面的"r"表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。

#### 4.4.3 内嵌汇编语法

```
__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
```

共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用":"格开，汇编语句模板必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用":"格开，相应部分内容为空。例如：

```asm
__asm__ __volatile__("cli": : :"memory")
```

1、汇编语句模板

汇编语句模板由汇编语句序列组成，语句之间使用";"、"\n"或"\n\t"分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：%0，%1，...，%9。指令中使用占位符表示的操作数，总被视为long型（4个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，"b"代表低字节，"h"代表高字节，例如：%h1。

2、输出部分

输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C 语言变量组成。每个输出操作数的限定字符串必须包含"="表示他是一个输出操作数。
例：

```assembly
__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x) )
```

描述符字符串表示对该变量的限制条件，这样GCC 就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与C表达式或C变量之间的联系。

3、输入部分
输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和C语言表达式或者C语言变量组成。
例1 ：

```assembly
__asm__ __volatile__ ("lidt %0" : : "m" (real_mode_idt));
```


例二（bitops.h）：

```c
Static __inline__ void __set_bit(int nr, volatile void * addr)
{
     __asm__(
             "btsl %1,%0"
             :"=m" (ADDR)
             :"Ir" (nr));
}
```

后 例功能是将(*addr)的第nr位设为1。第一个占位符%0与C 语言变量ADDR对应，第二个占位符%1与C语言变量nr对应。因此上面的汇编语句代码与下面的伪代码等价：btsl nr, ADDR，该指令的两个操作数不能全是内存变量，因此将nr的限定字符串指定为"Ir"，将nr 与立即数或者寄存器相关联，这样两个操作数中只有ADDR为内存变量。



4、限制字符
  4.1、限制字符列表
  限制字符有很多种，有些是与特定体系结构相关，此处仅列出常用的限定字符和i386中可能用到的一些常用的限定符。它们的作用是指示编译器如何处理其后的C语言变量与指令操作数之间的关系。

| 分类         | 限定符 | 描述                                                         |
| ------------ | ------ | ------------------------------------------------------------ |
| 通用寄存器   | "a"    | 将输入变量放入eax<br />这里有一个问题：假设eax已经被使用，那怎么办？<br/>其实很简单：因为GCC 知道eax 已经被使用，它在这段汇编代码<br/>的起始处插入一条语句pushl %eax，将eax 内容保存到堆栈，然<br/>后在这段代码结束处再增加一条语句popl %eax，恢复eax的内容 |
|              | "b"    | 将输入变量放入ebx                                            |
|              | "c"    | 将输入变量放入ecx                                            |
|              | "d"    | 将输入变量放入edx                                            |
|              | "s"    | 将输入变量放入esi                                            |
|              | "d"    | 将输入变量放入edi                                            |
|              | "q"    | 将输入变量放入eax，ebx，ecx，edx中的一个                     |
|              | "r"    | 将输入变量放入通用寄存器，也就是eax，ebx，ecx,  edx，esi，edi中的一个 |
|              | "A"    | 把eax和edx合成一个64 位的寄存器(use long longs)              |
| 内存         | "m"    | 内存变量                                                     |
|              | "o"    | 操作数为内存变量，但是其寻址方式是偏移量类型, 也即是基址寻址，或者是基址加变址寻址 |
|              | "V"    | 操作数为内存变量，但寻址方式不是偏移量类型                   |
|              | " "    | 操作数为内存变量，但寻址方式为自动增量                       |
|              | "p"    | 操作数是一个合法的内存地址（指针）                           |
| 寄存器或内存 | "g"    | 将输入变量放入eax，ebx，ecx，edx中的一个或者作为内存变量     |
|              | "X"    | 操作数可以是任何类型                                         |
| 立即数       | "I"    | 0-31之间的立即数（用于32位移位指令）                         |
|              | "J"    | 0-63之间的立即数（用于64位移位指令）                         |

​           "N"       0-255之间的立即数（用于out指令）
​           "i"       立即数 
​           "n"      立即数，有些系统不支持除字以外的立即数，
​                    这些系统应该使用"n"而不是"i"

   匹配       " 0 "，     表示用它限制的操作数与某个指定的操作数匹配，
           "1" ...        也即该操作数就是指定的那个操作数，例如"0"
            "9"      去描述"％1"操作数，那么"%1"引用的其实就
                    是"%0"操作数，注意作为限定符字母的0－9 与
                    指令中的"％0"－"％9"的区别，前者描述操作数，
                    后者代表操作数。
            &           该输出操作数不能使用过和输入操作数相同的寄存器

  操作数类型     "="     操作数在指令中是只写的（输出操作数） 
            "+"     操作数在指令中是读写类型的（输入输出操作数）

   浮点数       "f"     浮点寄存器
            "t"      第一个浮点寄存器
            "u"     第二个浮点寄存器
            "G"     标准的80387浮点常数
            %          该操作数可以和下一个操作数交换位置
                    例如addl的两个操作数可以交换顺序
                   （当然两个操作数都不能是立即数）
            \#          部分注释，从该字符到其后的逗号之间所有字母被忽略
            \*           表示如果选用寄存器，则其后的字母被忽略

5、破坏描述部分

破坏描述符用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成，每个字符串描述一种情况，一般是寄存器名；除寄存器外还有"memory"。例如："%eax"，"%ebx"，"memory"等。

"memory"比较特殊，可能是内嵌汇编中最难懂部分。为解释清楚它，先介绍一下编译器的优化知识，再看C关键字volatile。最后去看该描述符。

1、编译器优化介绍
  内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。另外在现代CPU中指令的执行并不一定 严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件级别的优化。再看软件一级的优化：一种是在编 写代码时由程序员优化，另一种是由编译器进行优化。编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重 新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处 理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏解决编译器的执行顺序问题。

```
               void Barrier(void)
```

这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。

2、C语言关键字volatile
   C 语言关键字volatile（注意它是用来修饰变量而不是上面介绍的__volatile__）表明某个变量的值可能在外部被改变，因此对这些变量的存取 不能缓存到寄存器，每次使用时需要重新存取。该关键字在多线程环境下经常使用，因为在编写多线程的程序时，同一个变量可能被多个线程修改，而程序通过该变 量同步各个线程，例如：

```
   DWORD __stdcall threadFunc(LPVOID signal)
   {
    int* intSignal=reinterpret_cast<int*>(signal);
    *intSignal=2;
    while(*intSignal!=1)
         sleep(1000);
    return 0;
   }
```

该线程启动时将intSignal 置为2，然后循环等待直到intSignal 为1 时退出。显然intSignal的值必须在外部被改变，否则该线程不会退出。但是实际运行的时候该线程却不会退出，即使在外部将它的值改为1，看一下对应的伪汇编代码就明白了：

```
  mov ax,signal
   label:
   if(ax!=1)
        goto label
```

  对于C编译器来说，它并不知道这个值会被其他线程修改。自然就把它cache在寄存器里面。记住，C 编译器是没有线程概念的！这时候就需要用到volatile。volatile 的本意是指：这个值可能会在当前线程外部被改变。也就是说，我们要在threadFunc中的intSignal前面加上volatile关键字，这时 候，编译器知道该变量的值会在外部改变，因此每次访问该变量时会重新读取，所作的循环变为如下面伪码所示：

```
  label:
   mov ax,signal
   if(ax!=1)
       goto label
```



3、Memory
   有了上面的知识就不难理解Memory修改描述符了，Memory描述符告知GCC：
   1）不要将该段内嵌汇编指令与前面的指令重新排序；也就是在执行内嵌汇编代码之前，它前面的指令都执行完毕
   2）不要将变量缓存到寄存器，因为这段代码可能会用到内存变量，而这些内存变量会以不可预知的方式发生改变，因此GCC插入必要的代码先将缓存到寄存器的变量值写回内存，如果后面又访问这些变量，需要重新访问内存。

  如果汇编指令修改了内存，但是GCC 本身却察觉不到，因为在输出部分没有描述，此时就需要在修改描述部分增加"memory"，告诉GCC 内存已经被修改，GCC 得知这个信息后，就会在这段指令之前，插入必要的指令将前面因为优化Cache 到寄存器中的变量值先写回内存，如果以后又要使用这些变量再重新读取。

  使用"volatile"也可以达到这个目的，但是我们在每个变量前增加该关键字，不如使用"memory"方便

### 4.5 C99中的柔性数组

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 一个结构体，成员变量是未指明大小的数组
typedef struct _ArraryMemberStruct_Good_ {
    int num;
    char data[];
} ArraryMemberStruct_Good;

void main()
{
    // 打印结构体的大小
    int size = sizeof(ArraryMemberStruct_Good);
    printf("size = %d \n", size);

    // 为结构体指针分配空间
    ArraryMemberStruct_Good *ams = (ArraryMemberStruct_Good *)malloc(size + 1024);

    strcpy(ams->data, "hello");
    printf("ams->data = %s \n", ams->data);

    // 打印结构体指针、成员变量的地址
    printf("ams = 0x%p \n", ams);
    printf("ams->num  = 0x%p \n", &ams->num);
    printf("ams->data = 0x%p \n", ams->data);

    // 释放空间
    free(ams);
}
```

打印结果：

> size = 4
> ams->data = hello
> ams = 0x0x5628271876b0
> ams->num  = 0x0x5628271876b0
> ams->data = 0x0x5628271876b4

特点：

1. 结构体的大小变成了 4；
2. 为结构体指针分配空间时，除了结构体本身的大小外，还申请了 data 需要的空间大小；
3. 不需要为 data 单独分配空间了；
4. 释放空间时，直接释放结构体指针即可；

### 4.6 lwip



#### 4.6.1 地址转换

大端模式和小端模式

0x12345678

如果存储这个4 bytes的数据时，低位字节 0x78放到存储介质的低地址 ，高位字节0x12放到存储介质的高地址，就是**小端模式**。

相反的，低位字节0x78放到了存储的高地址，高位字节放到了存储介质的低地址，就是**大端模式**

常见的字节序

一般**操作系统**都是小端，而**通信协议**都是大端。
 **CPU字节序**：
 Big Endian : PowerPC、IBM、Sun
 Little Endian : x86、DEC, riscv
 ARM既可以工作在大端模式，也可以工作在小端模式。
 **文件字节序**：
 GIF – Little Endian
 JPEG – Big Endian



htons()、htonl()、ntohl()、ntohs()函数

从软件的角度上看，不同端模式的处理器进行**数据传递时必须要考虑端模式的不同**。如进行网络数据传递时，必须要考虑端模式的转换。以下几个函数用于大小端字节序的转换：

```c
#define ntohs(n)     //16位数据类型网络字节顺序到主机字节顺序的转换   
#define htons(n)     //16位数据类型主机字节顺序到网络字节顺序的转换   
#define ntohl(n)      //32位数据类型网络字节顺序到主机字节顺序的转换   
#define htonl(n)      //32位数据类型主机字节顺序到网络字节顺序的转换  
```

其中互联网使用的**网络字节顺序采用大端模式进行编址**，而**主机字节顺序根据处理器的不同而不同**，如PowerPC处理器使用大端模式，而Pentuim处理器使用小端模式。
 大端模式处理器的字节序到网络字节序不需要转换，而**小端模式处理器的字节序到网络字节必须要进行转换**。 **不过为了移植性，在转换成网络字节序时，最好都使用htons()或htonl()函数**。

1） 把ip地址转化为用于网络传输的二进制数值

```c
int inet_aton(const char *cp, struct in_addr *inp);
```

inet_aton() 转换网络主机地址ip(如192.168.1.10)为二进制数值，并存储在struct in_addr结构中，即第二个参数*inp,函数返回非0表示cp主机有地有效，返回0表示主机地址无效。（这个转换完后不能用于网络传输，还需要调用htons或htonl函数才能将主机字节顺序转化为网络字节顺序）

```c
in_addr_t inet_addr(const char *cp);
```

inet_addr函数转换网络主机地址（如192.168.1.10)为网络字节序二进制值，如果参数char *cp无效，函数返回-1(INADDR_NONE),这个函数在处理地址为255.255.255.255时也返回－1,255.255.255.255是一个有效的地址，不过inet_addr无法处理;



2）将网络传输的二进制数值转化为成点分十进制的ip地址

```c
char *inet_ntoa(struct in_addr in);
```

inet_ntoa 函数转换网络字节排序的地址为标准的ASCII以点分开的地址,该函数返回指向点分开的字符串地址（如192.168.1.10)的指针，该字符串的空间为静态分配的，这意味着在第二次调用该函数时，上一次调用将会被重写（复盖），所以如果需要保存该串最后复制出来自己管理！

```c
#include <stdio.h>   
#include <sys/socket.h>   
#include <netinet/in.h>   
#include <arpa/inet.h>   
#include <string.h>   
int main()   
{   
	struct in_addr addr1,addr2;   
	ulong l1,l2;   
	l1= inet_addr("192.168.0.74");   
	l2 = inet_addr("211.100.21.179");   
	memcpy(&addr1, &l1, 4);   
	memcpy(&addr2, &l2, 4);   
	printf("%s : %s\n", inet_ntoa(addr1), inet_ntoa(addr2)); //注意这一句的运行结果   
	printf("%s\n", inet_ntoa(addr1));   
	printf("%s\n", inet_ntoa(addr2));  
	return 0;   
}
```

> 运行结果：
>
> 192.168.0.74 : 192.168.0.74
> 192.168.0.74
> 211.100.21.179

3）网路地址转化函数inet_pton和inet_ntop

这两个函数是随IPv6出现的函数，对于IPv4地址和IPv6地址都适用，函数中p和n分别代表表达（presentation)和数值（numeric)。地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构的二进制值。

```c
#include <arpe/inet.h>
int inet_pton(int family, const char *strptr, void *addrptr);     //将点分十进制的ip地址转化为用于网络传输的数值格式
        返回值：若成功则为1，若输入不是有效的表达式则为0，若出错则为-1

const char * inet_ntop(int family, const void *addrptr, char *strptr, size_t len);     //将数值格式转化为点分十进制的ip地址格式
```

1）这两个函数的family参数既可以是AF_INET（ipv4）也可以是AF_INET6（ipv6）。如果，以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.
（2）第一个函数尝试转换由strptr指针所指向的字符串，并通过addrptr指针存放二进制结果，若成功则返回值为1，否则如果所指定的family而言输入字符串不是有效的表达式格式，那么返回值为0.

（3）inet_ntop进行相反的转换，从数值格式（addrptr）转换到表达式（strptr)。inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。如果len太小，不足以容纳表达式结果，那么返回一个空指针，并置为errno为ENOSPC。

4）htonl



### 4.7 socket



#### 4.7.1  socket 

4.7.1 地址

socket编程中，经常见到这两个结构提来处理网络地址：struct sockaddr 和 struct sockaddr_in 。

对于 sockaddr，引用  \#include <sys/socket.h>  头文件就可以，其结构体：

```c
struct sockaddr {
  uint8_t     sa_len;
  sa_family_t sa_family;
  char sa_data[14];
};
```

对于 sockaddr_in, 引用\#include<netinet/in.h> 可以找到，其结构体

```c
struct sockaddr_in {
 u8_t           sin_len;
 sa_family_t    sin_family;
 in_port_t      sin_port;
 struct in_addr sin_addr;
 #define SIN_ZERO_LEN 8
 char       sin_zero[SIN_ZERO_LEN];
};
```

这个结构体中还有一个 struct in_addr sin_addr 的结构体。其定义如下：

```c
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;

struct in_addr {
  in_addr_t s_addr;
};
```

在socket编程中，sin_port 和 sin_addr 都必须是网络字节序。因此需要用 htons 转化实际的端口值。

在lwip中，这两个都定义在sockets.h 文件中。

可以看到两个结构体的大小是一致的，都是16字节。因此可以互相转化，指向sockaddr_in结构的指针也可以指向sockaddr。

sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的套接字地址。
sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。

一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于[socket](https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020)定义和赋值；sockaddr用于函数参数。



#### 4.7.2 select

API 原型

```c
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int select(int maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout);
```

参数说明：

maxfdp：集合中所有文件描述符的范围，为所有文件描述符的最大值加1

readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合

timeout: select的超时时间，它可以使select处于三种状态

- 若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；
- 若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数， 不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；
- timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回。

timeval结构体定义：

```c
struct timeval
{      
    long tv_sec;   /*秒 */
    long tv_usec;  /*微秒 */   
};
```

返回值：

0 --- 超时

-1 --- 失败

\>0 --- 标识就绪描述符的数目

使用select函数时，常用的几个宏

```c
#include <sys/select.h>   
FD_ZERO(fd_set*);       //清空fd_set集合，即让fd_set集合不再包含任何文件句柄。
FD_CLR(int ,fd_set*)    //清除某个位时可以使用
FD_SET(int ,fd_set *);   //将一个给定的文件描述符从集合中删除
FD_ISSET(int ,fd_set*);  //检测fd在fdset集合中的状态是否变化，当检测到fd状态发生变化时返回真,否则返回假。判断集合中指定的文件描述符是否可以读写
```

fd_set:  每一个bit对应一个文件描述符

使用select函数的过程一般是：

1. 先调用宏FD_ZERO将指定的fd_set清零
2. 然后调用宏FD_SET将需要测试的fd加入fd_set
3. 接着调用函数select测试fd_set中的所有fd
4. 最后用宏FD_ISSET检查某个fd在函数select调用后，相应位是否仍然为1



### 4.8 u-boot

#### 4.8.1 起源

  U-Boot 起源于 Magnus Damm 编写的名为 8xxROM 的针对于 8xx PowerPC 的引导加载程序。1999 年 10 月，Wolfgang Denk 将其在 SourceForge.net 开源，由于该网站不允许项目名称以数字开头，因此，更名为 PPCBoot（即 PowerPC Boot 的缩写）。2000 年 7 月 19 日首次公开发布 PPCBoot-0.4.1。

> 1. Wolfgang Denk 是 DENX Software Engineering GmbH（简称 DENX） 的创始人，PPCBoot 实际属于 DENX 公司
> 2. 因为 linus ➔ linux 所以 Denk ➔ DENX ？
> 3. DENX 是一家致力于使用自由软件的公司

随着 PPCBoot 被扩展到了 ARM 架构，DENX 认为，PPCBoot 这个名字已经不再合适，于是，在 PPCBoot−2.0.0 于 2002 年 10 月发布时决定将项目更名（SourceForge.net 新建项目）为 Das U-Boot（Universal Boot Loader 的缩写），其中的 Das 是一个德语定冠词，官方说是为了创建一个双关语（致敬经典的 1981 年德国潜艇电影 Das Boot）。

> 1. 代码仓库：https://source.denx.de/u-boot
> 2. Github 仓库：https://github.com/u-boot/u-boot

从 2008 年 10 月的版本开始，U-Boot 版本的名称从没有更深层次含义的数字版本号更改为基于时间戳的编号，通常格式 U-Boot vYYYY.MM.x，其中，YYYY 是年份（如 2022）；MM 是月份（如 08）；.x 可能没有，如果存在，这部分是 bug 修复版本（如 1）或者候选版本（如 rc1）。

U-Boot 的源码的结构基本也是向 Linux 看齐（其中部分代码就来自于 Linux kernel），只不过没有 Linux 代码那么复杂。如今，U-Boot 源码每天都有大量变更，最新的版本有 1 万 4 千多个文件，近 300 万行代码。源码中各文件的层级结构可以参考下图：
![uboot_code_archieve.png](https://z4a.net/images/2023/07/21/uboot_code_archieve.png)



4.8.2 uboot 编译

